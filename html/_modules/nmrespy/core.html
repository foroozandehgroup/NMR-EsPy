

<!doctype html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>nmrespy.core &#8212; NMR-EsPy  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/bizstyle.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!--[if lt IE 9]>
    <script src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">NMR-EsPy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">nmrespy.core</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for nmrespy.core</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">nmrespy</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">nmrespy._cols</span> <span class="k">as</span> <span class="nn">cols</span>
<span class="k">if</span> <span class="n">cols</span><span class="o">.</span><span class="n">USE_COLORAMA</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">colorama</span>
    <span class="n">colorama</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>
<span class="kn">import</span> <span class="nn">nmrespy._errors</span> <span class="k">as</span> <span class="nn">errors</span>
<span class="kn">from</span> <span class="nn">nmrespy._misc</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">nmrespy.load</span> <span class="kn">import</span> <span class="n">load_bruker</span>
<span class="kn">from</span> <span class="nn">nmrespy.freqfilter</span> <span class="kn">import</span> <span class="n">FrequencyFilter</span>
<span class="kn">from</span> <span class="nn">nmrespy.mpm</span> <span class="kn">import</span> <span class="n">MatrixPencil</span>
<span class="kn">from</span> <span class="nn">nmrespy.nlp.nlp</span> <span class="kn">import</span> <span class="n">NonlinearProgramming</span>
<span class="kn">from</span> <span class="nn">nmrespy.plot</span> <span class="kn">import</span> <span class="n">plot_result</span>
<span class="kn">from</span> <span class="nn">nmrespy.write</span> <span class="kn">import</span> <span class="n">write_result</span>
<span class="kn">from</span> <span class="nn">nmrespy</span> <span class="kn">import</span> <span class="n">sig</span>


<div class="viewcode-block" id="Estimator"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator">[docs]</a><span class="k">class</span> <span class="nc">Estimator</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Estimation class</span>

<span class="sd">    .. note::</span>
<span class="sd">       The methods :py:meth:`new_bruker`, :py:meth:`new_synthetic_from_data`</span>
<span class="sd">       and :py:meth:`new_synthetic_from_parameters` generate instances</span>
<span class="sd">       of the class. The method :py:meth:`from_pickle` loads an estimator</span>
<span class="sd">       instance that was previously saved using :py:meth:`to_pickle`.</span>
<span class="sd">       While you can manually input the listed parameters</span>
<span class="sd">       as arguments to initialise the class, it is more straightforward</span>
<span class="sd">       to use one of these.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    source : &#39;bruker_fid&#39;, &#39;bruker_pdata&#39;, &#39;synthetic&#39;</span>
<span class="sd">        The type of data imported. `&#39;bruker_fid&#39;` indicates the data is</span>
<span class="sd">        derived from a FID file (`fid` for 1D data, `ser` for 2D data).</span>
<span class="sd">        `&#39;bruker_pdata&#39;` indicates the data is derived from files found</span>
<span class="sd">        in a `pdata` directory (`1r` for 1D data; `2rr` for 2D data).</span>
<span class="sd">        `&#39;synthetic&#39;` indicates that the data is synthetic.</span>

<span class="sd">    data : numpy.ndarray</span>
<span class="sd">        The data associated with the binary file in `path`.</span>

<span class="sd">    path : pathlib.Path or None</span>
<span class="sd">        The path to the directory contaioning the NMR data.</span>

<span class="sd">    sw : [float] or [float, float]</span>
<span class="sd">        The experiment sweep width in each dimension (Hz).</span>

<span class="sd">    offset : [float] or [float, float]</span>
<span class="sd">        The transmitter&#39;s offset frequency in each dimension (Hz).</span>

<span class="sd">    sfo : [float] or [float, float] or None</span>
<span class="sd">        The transmitter frequency in each dimension (MHz)</span>

<span class="sd">    nuc : [str] or [str, str] or None</span>
<span class="sd">        The nucleus in each dimension. Elements will be of the form</span>
<span class="sd">        `&#39;&lt;mass&gt;&lt;element&gt;&#39;`, where `&#39;&lt;mass&gt;&#39;` is the mass number of the</span>
<span class="sd">        isotope and `&#39;&lt;element&gt;&#39;` is the chemical symbol of the element.</span>

<span class="sd">    fmt : str or None</span>
<span class="sd">        The format of the binary file from which the data was obtained.</span>
<span class="sd">        Of the form `&#39;&lt;endian&gt;&lt;unitsize&gt;&#39;`, where `&#39;&lt;endian&gt;&#39;` is either</span>
<span class="sd">        `&#39;&lt;&#39;` (little endian) or `&#39;&gt;&#39;` (big endian), and `&#39;&lt;unitsize&gt;&#39;`</span>
<span class="sd">        is either `&#39;i4&#39;` (32-bit integer) or `&#39;f8&#39;` (64-bit float).</span>

<span class="sd">    _origin : dict or None, default None</span>
<span class="sd">        For internal use. Specifies how the instance was initalised. If `None`,</span>
<span class="sd">        implies that the instance was initialised manually, rather than using</span>
<span class="sd">        one of :py:meth:`new_bruker`, :py:meth:`new_synthetic_from_data`</span>
<span class="sd">        and :py:meth:`new_synthetic_from_parameters`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">sfo</span><span class="p">,</span> <span class="n">nuc</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">_origin</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">ndim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sw</span> <span class="o">=</span> <span class="n">sw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">off</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span> <span class="o">=</span> <span class="n">sfo</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nuc</span> <span class="o">=</span> <span class="n">nuc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span>

        <span class="c1"># Attributes that will be assigned to after the user runs</span>
        <span class="c1"># the folowing methods:</span>
        <span class="c1"># * frequency_filter (filter_info)</span>
        <span class="c1"># * matrix_pencil or nonlinear_programming (result)</span>
        <span class="c1"># * nonlinear_programming (errors)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Specifies whether the last time self.result was changed</span>
        <span class="c1"># was when nonlinear_prograaming was called.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Create a converter object, enabling conversion idx, hz (and ppm,</span>
        <span class="c1"># if sfo is not None)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_converter</span> <span class="o">=</span> <span class="n">FrequencyConverter</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span>
        <span class="p">)</span>

        <span class="c1"># --- Create attribute for logging method calls ------------------</span>
        <span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;==============================</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;Logfile for Estimator instance</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="s2">&quot;==============================</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;--&gt; Instance created @ </span><span class="si">{</span><span class="n">now</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%m-%y %H:%M:%S&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">_origin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span> <span class="o">+=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot; from `</span><span class="si">{</span><span class="n">_origin</span><span class="p">[</span><span class="s1">&#39;method&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">` with args &quot;</span>
                          <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">_origin</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;nmrespy.core.Estimator(&#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sfo</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nuc</span><span class="si">}</span><span class="s1">, &#39;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">fmt</span><span class="si">}</span><span class="s1">)&#39;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">msg</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A formatted list of class attributes&quot;&quot;&quot;</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">MA</span><span class="si">}</span><span class="s2">&lt;</span><span class="si">{</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s2"> at &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="n">dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span>
        <span class="n">keys</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">dic</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">MA</span><span class="si">}{</span><span class="n">k</span><span class="si">}{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1"> : </span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s1">&#39;</span>
                 <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;_&#39;</span><span class="p">]</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">msg</span>

<div class="viewcode-block" id="Estimator.logger"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.logger">[docs]</a>    <span class="k">def</span> <span class="nf">logger</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decorator for logging :py:class:`Estimator` method calls&quot;&quot;&quot;</span>
        <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># The first arg is the class instance.</span>
            <span class="c1"># Append to the log text.</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_log</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;--&gt; `</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">` </span><span class="si">{</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="si">}</span><span class="s1"> </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="se">\n</span><span class="s1">&#39;</span>

            <span class="c1"># Run the method...</span>
            <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">wrapper</span></div>

<div class="viewcode-block" id="Estimator.new_bruker"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.new_bruker">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">new_bruker</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="nb">dir</span><span class="p">,</span> <span class="n">ask_convdta</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate an instance of :py:class:`Estimator` from a</span>
<span class="sd">        Bruker-formatted data directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dir : str</span>
<span class="sd">            The path to the data containing the data of interest.</span>

<span class="sd">        ask_convdta : bool</span>
<span class="sd">            See :py:meth:`nmrespy.load_bruker`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimator : :py:class:`Estimator`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For a more detailed specification of the directory requirements,</span>
<span class="sd">        see :py:meth:`nmrespy.load_bruker`.&quot;&quot;&quot;</span>

        <span class="n">origin</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;new_bruker&#39;</span><span class="p">,</span> <span class="s1">&#39;args&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()}</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">load_bruker</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">ask_convdta</span><span class="o">=</span><span class="n">ask_convdta</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;source&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">],</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sweep_width&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;transmitter_frequency&#39;</span><span class="p">],</span>
            <span class="n">info</span><span class="p">[</span><span class="s1">&#39;nuclei&#39;</span><span class="p">],</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;binary_format&#39;</span><span class="p">],</span> <span class="n">_origin</span><span class="o">=</span><span class="n">origin</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.from_pickle"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.from_pickle">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads an intance of :py:class:`Estimator`, which was saved</span>
<span class="sd">        previously using :py:meth:`to_pickle`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            The path to the pickle file. **DO NOT INCLUDE THE FILE</span>
<span class="sd">            EXTENSION.**</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimator : :py:class:`Estimator`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        .. warning::</span>
<span class="sd">           `From the Python docs:`</span>

<span class="sd">           *&quot;The pickle module is not secure. Only unpickle data you trust.</span>
<span class="sd">           It is possible to construct malicious pickle data which will</span>
<span class="sd">           execute arbitrary code during unpickling. Never unpickle data</span>
<span class="sd">           that could have come from an untrusted source, or that could have</span>
<span class="sd">           been tampered with.&quot;*</span>

<span class="sd">           You should only use :py:meth:`from_pickle` on files that</span>
<span class="sd">           you are 100% certain were generated using</span>
<span class="sd">           :py:meth:`to_pickle`. If you load pickled data from a .pkl file,</span>
<span class="sd">           and the resulting output is not an instance of</span>
<span class="sd">           :py:class:`Estimator`, an error will be raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="vm">__class__</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">It is expected that the object opened by&#39;</span>
                    <span class="s1">&#39; `from_pickle` is an instance of&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s1">.</span><span class="si">{</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__qualname__</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; What was loaded didn</span><span class="se">\&#39;</span><span class="s1">t satisfy this!</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">Invalid path specified.</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.to_pickle"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.to_pickle">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./estimator&#39;</span><span class="p">,</span> <span class="n">force_overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fprint</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts the class instance to a byte stream using Python&#39;s</span>
<span class="sd">        &quot;Pickling&quot; protocol, and saves it to a .pkl file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, default: &#39;./estimator&#39;</span>
<span class="sd">            Path of file to save the byte stream to. **DO NOT INCLUDE A</span>
<span class="sd">            `&#39;.pkl&#39;` EXTENSION!** `&#39;.pkl&#39;` is added to the end of the path</span>
<span class="sd">            automatically.</span>

<span class="sd">        force_overwrite : bool, default: False</span>
<span class="sd">            Defines behaviour if ``f&#39;{path}.pkl&#39;`` already exists:</span>

<span class="sd">            * If `force_overwrite` is set to `False`, the user will be prompted</span>
<span class="sd">              if they are happy overwriting the current file.</span>
<span class="sd">            * If `force_overwrite` is set to `True`, the current file will be</span>
<span class="sd">              overwritten without prompt.</span>

<span class="sd">        fprint : bool, default: True</span>
<span class="sd">            Specifies whether or not to print infomation to the terminal.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method complements :py:meth:`from_pickle`, in that</span>
<span class="sd">        an instance saved using :py:meth:`to_pickle` can be recovered by</span>
<span class="sd">        :py:func:`~nmrespy.load.pickle_load`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ArgumentChecker</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;str&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">force_overwrite</span><span class="p">,</span> <span class="s1">&#39;force_overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">fprint</span><span class="p">,</span> <span class="s1">&#39;fprint&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get full path</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="c1"># Append extension to file path</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.pkl&#39;</span><span class="p">)</span>
        <span class="c1"># Check path is valid (check directory exists, ask user if they are</span>
        <span class="c1"># happy overwriting if file already exists).</span>
        <span class="n">pathres</span> <span class="o">=</span> <span class="n">PathManager</span><span class="p">(</span>
            <span class="n">path</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">parent</span>
        <span class="p">)</span><span class="o">.</span><span class="n">check_file</span><span class="p">(</span><span class="n">force_overwrite</span><span class="p">)</span>
        <span class="c1"># Valid path, we are good to proceed</span>
        <span class="k">if</span> <span class="n">pathres</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Overwrite denied by the user. Exit the program</span>
        <span class="k">elif</span> <span class="n">pathres</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># pathres == 2: Directory specified doesn&#39;t exist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">The directory implied by path does not&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;exist</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fh</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fprint</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">G</span><span class="si">}</span><span class="s1">Saved instance of Estimator to </span><span class="si">{</span><span class="n">path</span><span class="si">}{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_datapath"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_datapath">[docs]</a>    <span class="k">def</span> <span class="nf">get_datapath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="s1">&#39;Path&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return path of the data directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        type_ : &#39;Path&#39; or &#39;str&#39;, default: &#39;Path&#39;</span>
<span class="sd">            The type of the returned path. If `&#39;Path&#39;`, the returned object</span>
<span class="sd">            is an instance of `pathlib.Path &lt;https://docs.python.org/3/\</span>
<span class="sd">            library/pathlib.html#pathlib.Path&gt;`_. If `&#39;str&#39;`, the returned</span>
<span class="sd">            object is an instance of str.</span>

<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If the path is `None`, `kill` specifies how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        path : str or pathlib.Path</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;Path&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">elif</span> <span class="n">type_</span> <span class="o">==</span> <span class="s1">&#39;str&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">R</span><span class="si">}</span><span class="s1">type_ should be </span><span class="se">\&#39;</span><span class="s1">Path</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">str</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_data"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the original data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : numpy.ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span></div>

<div class="viewcode-block" id="Estimator.get_dim"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_dim">[docs]</a>    <span class="k">def</span> <span class="nf">get_dim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the data dimension.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dim : 1 or 2</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span></div>

<div class="viewcode-block" id="Estimator.get_n"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_n">[docs]</a>    <span class="k">def</span> <span class="nf">get_n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of datapoints in each dimension</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : [int] or [int, int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span></div>

<div class="viewcode-block" id="Estimator.get_sw"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_sw">[docs]</a>    <span class="k">def</span> <span class="nf">get_sw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the experiment sweep width in each dimension.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>

<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `unit` is `&#39;ppm&#39;`, but `self.sfo` is `None`, `kill` specifies</span>
<span class="sd">            how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sw : [float] or [float, float]</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidUnitError</span>
<span class="sd">            If `unit` is not `&#39;hz&#39;` or `&#39;ppm&#39;`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `unit` is set to `&#39;ppm&#39;` and `self.sfo` is not specified</span>
<span class="sd">        (`None`), there is no way of retreiving the sweep width in ppm.</span>
<span class="sd">        `None` will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sw</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;hz&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sw</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">sfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">(</span><span class="n">kill</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">sw</span><span class="p">,</span> <span class="s1">&#39;hz-&gt;ppm&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_offset"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_offset">[docs]</a>    <span class="k">def</span> <span class="nf">get_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the transmitter&#39;s offset frequency in each dimesnion.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        offset : [float] or [float, float]</span>

<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `unit` is `&#39;ppm&#39;`, but `self.sfo` is `None`, `kill` specifies</span>
<span class="sd">            how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidUnitError</span>
<span class="sd">            If `unit` is not `&#39;hz&#39;` or `&#39;ppm&#39;`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If `unit` is set to `&#39;ppm&#39;` and `self.sfo` is not specified</span>
<span class="sd">        (`None`), there is no way of retreiving the offset in ppm.</span>
<span class="sd">        `None` will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;hz&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">elif</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">sfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">(</span><span class="n">kill</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="s1">&#39;hz-&gt;ppm&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_sfo"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_sfo">[docs]</a>    <span class="k">def</span> <span class="nf">get_sfo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return transmitter frequency for each channel (MHz).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If the path is `None`, `kill` specifies how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sfo : [float] or [float, float]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_bf"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_bf">[docs]</a>    <span class="k">def</span> <span class="nf">get_bf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the transmitter&#39;s basic frequency for each channel (MHz).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If the path is `None`, `kill` specifies how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bf : [float] or [float, float]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sfo</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">s</span> <span class="o">-</span> <span class="p">(</span><span class="n">o</span> <span class="o">/</span> <span class="mf">1E6</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sfo</span><span class="p">,</span> <span class="n">off</span><span class="p">)]</span></div>

<div class="viewcode-block" id="Estimator.get_nucleus"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_nucleus">[docs]</a>    <span class="k">def</span> <span class="nf">get_nucleus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the target nucleus of each channel.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If the path is `None`, `kill` specifies how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nuc : [str] or [str, str]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="s1">&#39;nuc&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_shifts"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_shifts">[docs]</a>    <span class="k">def</span> <span class="nf">get_shifts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="n">meshgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sampled frequencies consistent with experiment&#39;s</span>
<span class="sd">        parameters (sweep width, transmitter offset, number of points).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unit : &#39;ppm&#39; or &#39;hz&#39;, default: &#39;ppm&#39;</span>
<span class="sd">            The unit of the value(s).</span>

<span class="sd">        meshgrid : bool</span>
<span class="sd">            Only appicable for 2D data. If set to `True`, the shifts in</span>
<span class="sd">            each dimension will be fed into</span>
<span class="sd">            `numpy.meshgrid &lt;https://numpy.org/doc/stable/reference/\</span>
<span class="sd">            generated/numpy.meshgrid.html&gt;`_</span>

<span class="sd">        kill : bool</span>
<span class="sd">            If `self.sfo` (need to get shifts in ppm) is `None`, `kill`</span>
<span class="sd">            specifies how the method will act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifts : [numpy.ndarray] or [numpy.ndarray, numpy.ndarray]</span>
<span class="sd">            The frequencies sampled along each dimension.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        InvalidUnitError</span>
<span class="sd">            If `unit` is not `&#39;hz&#39;` or `&#39;ppm&#39;`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The shifts are returned in ascending order.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ppm&#39;</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;ppm&#39;</span><span class="p">,</span> <span class="s1">&#39;hz&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span> <span class="ow">and</span> <span class="n">kill</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="n">shifts</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">get_shifts</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="n">kill</span><span class="p">),</span> <span class="n">flip</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">meshgrid</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">shifts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">shifts</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">shifts</span></div>

<div class="viewcode-block" id="Estimator.get_timepoints"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_timepoints">[docs]</a>    <span class="k">def</span> <span class="nf">get_timepoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">meshgrid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the sampled times consistent with experiment&#39;s</span>
<span class="sd">        parameters (sweep width, number of points).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        meshgrid : bool</span>
<span class="sd">            Only appicable for 2D data. If set to `True`, the time-points in</span>
<span class="sd">            each dimension will be fed into</span>
<span class="sd">            `numpy.meshgrid &lt;https://numpy.org/doc/stable/reference/\</span>
<span class="sd">            generated/numpy.meshgrid.html&gt;`_</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tp : [numpy.ndarray] or [numpy.ndarray, numpy.ndarray]</span>
<span class="sd">            The times sampled along each dimension (seconds).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tp</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">get_timepoints</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">meshgrid</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">tp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">tp</span></div>

<div class="viewcode-block" id="Estimator.get_result"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_result">[docs]</a>    <span class="k">def</span> <span class="nf">get_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq_unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the estimation result</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `self.result` is `None`, `kill` specifies how the method will</span>
<span class="sd">            act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        freq_unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_errors"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_errors">[docs]</a>    <span class="k">def</span> <span class="nf">get_errors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">freq_unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the errors of the estimation result derived from</span>
<span class="sd">        :py:meth:`nonlinear_programming`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `self.errors` is `None`, `kill` specifies how the method will</span>
<span class="sd">            act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        freq_unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_array</span><span class="p">(</span><span class="s1">&#39;errors&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator._get_array"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator._get_array">[docs]</a>    <span class="k">def</span> <span class="nf">_get_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">freq_unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an array (result or errors), wioth frequencies in either</span>
<span class="sd">        Hz or ppm&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;result&quot;</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;matrix_pencil and/or nonlinear_programming&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;nonlinear_programming&quot;</span>

        <span class="n">array</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">errmsg</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">freq_unit</span> <span class="o">==</span> <span class="s1">&#39;hz&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array</span>

        <span class="k">elif</span> <span class="n">freq_unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="c1"># Get frequencies in Hz, and format to enable input into</span>
            <span class="c1"># the frequency converter.</span>
            <span class="c1"># Then convert values to ppm and reconvert back to NumPy array</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ppm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_converter</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span>
                        <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])],</span> <span class="n">conversion</span><span class="o">=</span><span class="s1">&#39;hz-&gt;ppm&#39;</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ppm</span>
                <span class="k">return</span> <span class="n">array</span>

            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">Error in trying to convert frequencies to &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;ppm. Perhaps you didn</span><span class="se">\&#39;</span><span class="s1">t specify sfo when you made &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;the Estimator instance?</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator._check_if_none"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator._check_if_none">[docs]</a>    <span class="k">def</span> <span class="nf">_check_if_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve attributes that may be assigned the value `None`. Return</span>
<span class="sd">        None/raise error depending on the value of ``kill``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the attribute requested.</span>

<span class="sd">        kill : bool</span>
<span class="sd">            Whether or not to raise an error if the desired attribute is</span>
<span class="sd">            `None`.</span>

<span class="sd">        method : str or None, default: None</span>
<span class="sd">            The name of the method that needs to be run to obtain the</span>
<span class="sd">            desired attribute. If `None`, it implies that the attribute</span>
<span class="sd">            requested was never given to the class in the first place.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        attribute : any</span>
<span class="sd">            The attribute requested.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">attribute</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">attribute</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kill</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">AttributeIsNoneError</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">attribute</span></div>

<div class="viewcode-block" id="Estimator.view_data"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.view_data">[docs]</a>    <span class="k">def</span> <span class="nf">view_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="n">freq_xunit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">,</span>
                  <span class="n">component</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generate a simple, interactive plot of the data using matplotlib.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        domain : &#39;frequency&#39; or &#39;time&#39;, default: &#39;frequency&#39;</span>
<span class="sd">            The domain of the sig.</span>

<span class="sd">        freq_xunit : &#39;ppm&#39; or &#39;hz&#39;, default: &#39;ppm&#39;</span>
<span class="sd">            The unit of the x-axis, if `domain` is set as `&#39;frequency&#39;`. If</span>
<span class="sd">            `domain` is set as `&#39;time&#39;`, the x-axis unit will the seconds.</span>

<span class="sd">        component : &#39;real&#39;, &#39;imag&#39; or &#39;both&#39;, default: &#39;real&#39;</span>
<span class="sd">            The component of the data to display. `&#39;both&#39;` displays both</span>
<span class="sd">            the real and imaginary components</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: 2D equivalent</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;time&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;$t</span><span class="se">\\</span><span class="s1"> (s)$&#39;</span>
                <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_timepoints</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">TwoDimUnsupportedError</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;frequency&#39;</span><span class="p">:</span>
            <span class="c1"># frequency domain treatment</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ydata</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>

                <span class="k">if</span> <span class="n">freq_xunit</span> <span class="o">==</span> <span class="s1">&#39;hz&#39;</span><span class="p">:</span>
                    <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">omega</span><span class="se">\\</span><span class="s1"> (Hz)$&#39;</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shifts</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">freq_xunit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
                    <span class="n">xlabel</span> <span class="o">=</span> <span class="s1">&#39;$</span><span class="se">\\</span><span class="s1">omega</span><span class="se">\\</span><span class="s1"> (ppm)$&#39;</span>
                    <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_shifts</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">R</span><span class="si">}</span><span class="s1">freq_xunit was not given a valid value&#39;</span> \
                          <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; (should be </span><span class="se">\&#39;</span><span class="s1">ppm</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">hz</span><span class="se">\&#39;</span><span class="s1">).</span><span class="si">{</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">TwoDimUnsupportedError</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">R</span><span class="si">}</span><span class="s1">domain was not given a valid value&#39;</span> \
                  <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; (should be </span><span class="se">\&#39;</span><span class="s1">frequency</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">time</span><span class="se">\&#39;</span><span class="s1">).</span><span class="si">{</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">component</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">component</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Re&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ydata</span><span class="p">),</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;#808080&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Im&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">R</span><span class="si">}</span><span class="s1">component was not given a valid value&#39;</span> \
                  <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39; (should be </span><span class="se">\&#39;</span><span class="s1">real</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">imag</span><span class="se">\&#39;</span><span class="s1"> or </span><span class="se">\&#39;</span><span class="s1">both</span><span class="se">\&#39;</span><span class="s1">).</span><span class="si">{</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">domain</span> <span class="o">==</span> <span class="s1">&#39;frequency&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">xdata</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xdata</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<span class="c1"># TODO</span>
<span class="c1"># make_fid:</span>
<span class="c1"># include functionality to write to Bruker files, Varian files,</span>
<span class="c1"># JEOL files etc</span>

<div class="viewcode-block" id="Estimator.make_fid"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.make_fid">[docs]</a>    <span class="k">def</span> <span class="nf">make_fid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">oscillators</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructs a synthetic FID using a parameter estimate and</span>
<span class="sd">        experiment parameters.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : [int], or [int, int], or None default: None</span>
<span class="sd">            The number of points to construct the FID with in each dimesnion.</span>
<span class="sd">            If `None`, :py:meth:`get_n` will be used, meaning the signal will</span>
<span class="sd">            have the same number of points as the original data.</span>

<span class="sd">        oscillators : None or list, default: None</span>
<span class="sd">            Which oscillators to include in result. If `None`, all</span>
<span class="sd">            oscillators will be included. If a list of ints, the subset of</span>
<span class="sd">            oscillators corresponding to these indices will be used. Note</span>
<span class="sd">            that all elements should be in ``range(self.result.shape[0])``.</span>

<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `self.result` is `None`, `kill` specifies how the method will</span>
<span class="sd">            act:</span>

<span class="sd">            * If `True`, an AttributeIsNoneError is raised.</span>
<span class="sd">            * If `False`, `None` is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fid : numpy.ndarray</span>
<span class="sd">            The generated FID.</span>

<span class="sd">        tp : [numpy.ndarray] or [numpy.ndarray, numpy.ndarray]</span>
<span class="sd">            The time-points at which the signal is sampled, in each dimension.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:func:`nmrespy.sig.make_fid`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="n">kill</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">oscillators</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">oscillators</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">()</span>

        <span class="n">ArgumentChecker</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;int_list&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">oscillators</span><span class="p">,</span> <span class="s1">&#39;oscillators&#39;</span><span class="p">,</span> <span class="s1">&#39;int_list&#39;</span><span class="p">),</span>
            <span class="p">],</span>
            <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">sig</span><span class="o">.</span><span class="n">make_fid</span><span class="p">(</span><span class="n">result</span><span class="p">[[</span><span class="n">oscillators</span><span class="p">]],</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">(),</span>
                            <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">())</span></div>

<div class="viewcode-block" id="Estimator.phase_data"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.phase_data">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">phase_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Phase `self.data`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p0 : [float], [float, float], or None default: None</span>
<span class="sd">            Zero-order phase correction in each dimension in radians.</span>
<span class="sd">            If `None`, the phase will be set to `0.0` in each dimension.</span>

<span class="sd">        p1 : [float], [float, float], or None default: None</span>
<span class="sd">            First-order phase correction in each dimension in radians.</span>
<span class="sd">            If `None`, the phase will be set to `0.0` in each dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">p1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">*</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">ift</span><span class="p">(</span>
            <span class="n">sig</span><span class="o">.</span><span class="n">phase</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">ft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.manual_phase_data"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.manual_phase_data">[docs]</a>    <span class="k">def</span> <span class="nf">manual_phase_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_p1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform manual phase correction of `self.data`.</span>

<span class="sd">        Zero- and first-order phase pharameters are determined via</span>
<span class="sd">        interaction with a Tkinter- and matplotlib-based graphical user</span>
<span class="sd">        interface.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        max_p1 : float or None, default: None</span>
<span class="sd">            Specifies the range of first-order phases permitted. For each</span>
<span class="sd">            dimension, the user will be allowed to choose a value of `p1`</span>
<span class="sd">            within [`-max_p1`, `max_p1`]. By default, `max_p1` will be</span>
<span class="sd">            ``10 * numpy.pi``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">manual_phase_spectrum</span><span class="p">(</span><span class="n">sig</span><span class="o">.</span><span class="n">ft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">max_p1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">p0</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">p1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_data</span><span class="p">(</span><span class="n">p0</span><span class="o">=</span><span class="p">[</span><span class="n">p0</span><span class="p">],</span> <span class="n">p1</span><span class="o">=</span><span class="p">[</span><span class="n">p1</span><span class="p">])</span></div>

<div class="viewcode-block" id="Estimator.frequency_filter"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.frequency_filter">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">frequency_filter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">region</span><span class="p">,</span> <span class="n">noise_region</span><span class="p">,</span> <span class="n">cut</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">region_unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates frequency-filtered data from `self.data`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        region: [[int, int]], [[int, int], [int, int]], [[float, float]] or</span>
<span class="sd">        [[float, float], [float, float]]</span>
<span class="sd">            Cut-off points of the spectral region to consider.</span>
<span class="sd">            If the signal is 1D, this should be of the form `[[a,b]]`</span>
<span class="sd">            where `a` and `b` are the boundaries.</span>
<span class="sd">            If the signal is 2D, this should be of the form</span>
<span class="sd">            `[[a,b], [c,d]]` where `a` and `b` are the boundaries in</span>
<span class="sd">            dimension 1, and `c` and `d` are the boundaries in</span>
<span class="sd">            dimension 2. The ordering of the bounds in each dimension is</span>
<span class="sd">            not important.</span>

<span class="sd">        noise_region: [[int, int]], [[int, int], [int, int]],</span>
<span class="sd">        [[float, float]] or [[float, float], [float, float]]</span>
<span class="sd">            Cut-off points of the spectral region to extract the spectrum&#39;s</span>
<span class="sd">            noise variance. This should have the same structure as `region`.</span>

<span class="sd">        cut : bool, default: True</span>
<span class="sd">            If `False`, the filtered signal will comprise the same number of</span>
<span class="sd">            data points as the original data. If `True`, prior to inverse</span>
<span class="sd">            FT, the data will be sliced, with points not in the region</span>
<span class="sd">            specified by `cut_ratio` being removed.</span>

<span class="sd">        cut_ratio : float, default: 2.5</span>
<span class="sd">            If cut is `True`, defines the ratio between the cut signal&#39;s sweep</span>
<span class="sd">            width, and the region width, in each dimesnion.</span>
<span class="sd">            It is reccommended that this is comfortably larger than `1.0`.</span>
<span class="sd">            `2.0` or higher should be appropriate.</span>

<span class="sd">        region_unit : &#39;ppm&#39;, &#39;hz&#39; or &#39;idx&#39;, default: &#39;ppm&#39;</span>
<span class="sd">            The unit the elements of `region` and `noise_region` are</span>
<span class="sd">            expressed in.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method assigns the attribute `filter_info` to an instance of</span>
<span class="sd">        :py:class:`nmrespy.freqfilter.FrequencyFilter`. To obtain information</span>
<span class="sd">        on the filtration, use :py:meth:`get_filter_info`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span> <span class="o">=</span> <span class="n">FrequencyFilter</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> <span class="n">region</span><span class="p">,</span> <span class="n">noise_region</span><span class="p">,</span> <span class="n">region_unit</span><span class="o">=</span><span class="n">region_unit</span><span class="p">,</span>
            <span class="n">sw</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">(),</span> <span class="n">offset</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">(),</span>
            <span class="n">sfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">cut</span><span class="o">=</span><span class="n">cut</span><span class="p">,</span> <span class="n">cut_ratio</span><span class="o">=</span><span class="n">cut_ratio</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.get_filter_info"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.get_filter_info">[docs]</a>    <span class="k">def</span> <span class="nf">get_filter_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kill</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns information relating to frequency filtration.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kill : bool, default: True</span>
<span class="sd">            If `filter_info` is `None`, and `kill` is `True`, an error will</span>
<span class="sd">            be raised. If `kill` is False, `None` will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filter_info : nmrespy.freqfilter.FrequencyFilter</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        There are numerous methods associated with `filter_info` for</span>
<span class="sd">        obtaining relavent infomation about the filtration. See</span>
<span class="sd">        :py:class:`nmrespy.freqfilter.FrequencyFilter` for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_none</span><span class="p">(</span>
            <span class="s1">&#39;filter_info&#39;</span><span class="p">,</span> <span class="n">kill</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;frequency_filter&#39;</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator._get_data_sw_offset"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator._get_data_sw_offset">[docs]</a>    <span class="k">def</span> <span class="nf">_get_data_sw_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieve data, sweep width and offset, based on whether</span>
<span class="sd">        frequency filtration have been applied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : numpy.ndarray</span>

<span class="sd">        sw : [float] or [float, float]</span>
<span class="sd">            Sweep width (Hz).</span>

<span class="sd">        offset : [float] or [float, float]</span>
<span class="sd">            Transmitter offset (Hz).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        * If `self.filter_info` is equal to `None`, `self.data` will be</span>
<span class="sd">          analysed</span>
<span class="sd">        * If `self.filter_info` is an instance of</span>
<span class="sd">          :py:class:`nmrespy.freqfilter.FrequencyFilter`,</span>
<span class="sd">          `self.filter_info.filtered_signal` will be analysed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span><span class="o">.</span><span class="n">get_fid</span><span class="p">()</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span><span class="o">.</span><span class="n">get_sw</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_info</span><span class="o">.</span><span class="n">get_offset</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">sw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">()</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">offset</span></div>

<div class="viewcode-block" id="Estimator.matrix_pencil"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.matrix_pencil">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">matrix_pencil</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fprint</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of the 1D Matrix Pencil Method [#]_ [#]_ or 2D</span>
<span class="sd">        Modified Matrix Enchancement and Matrix Pencil (MMEMP) method [#]_</span>
<span class="sd">        [#]_ with the option of Model Order Selection using the Minumum</span>
<span class="sd">        Descrition Length (MDL) [#]_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M : int, default: 0</span>
<span class="sd">            The number of oscillators to use in generating a parameter</span>
<span class="sd">            estimate. If `M` is set to `0`, the number of oscillators will be</span>
<span class="sd">            estimated using the MDL.</span>

<span class="sd">        trim : [int], [int, int], or None, default: None</span>
<span class="sd">            If `trim` is a list, the analysed data will be sliced such that</span>
<span class="sd">            its shape matches `trim`, with the initial points in the signal</span>
<span class="sd">            being retained. If `trim` is `None`, the data will not be</span>
<span class="sd">            sliced. Consider using this in cases where the full signal is</span>
<span class="sd">            large, such that the method takes a very long time, or your PC</span>
<span class="sd">            has insufficient memory to process it.</span>

<span class="sd">        fprint : bool, default: True</span>
<span class="sd">            If `True` (default), the method provides information on</span>
<span class="sd">            progress to the terminal as it runs. If `False`, the method</span>
<span class="sd">            will run silently.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The data analysed will be the following:</span>

<span class="sd">        * If `self.filter_info` is equal to `None`, `self.data` will be</span>
<span class="sd">          analysed</span>
<span class="sd">        * If `self.filter_info` is an instance of</span>
<span class="sd">          :py:class:`nmrespy.freqfilter.FrequencyFilter`,</span>
<span class="sd">          `self.filter_info.filtered_signal` will be analysed.</span>

<span class="sd">        **For developers:** See :py:meth:`_get_data_sw_offset`</span>

<span class="sd">        Upon successful completion is this method, `self.mpm_info` will</span>
<span class="sd">        be updated with an instance of :py:class:`nmrespy.mpm.MatrixPencil`.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [#] Yingbo Hua and Tapan K Sarkar. Matrix pencil method for</span>
<span class="sd">           estimating parameters of exponentially damped/undamped sinusoids</span>
<span class="sd">           in noise. In: IEEE Trans. Acoust., Speech, Signal Process. 38.5</span>
<span class="sd">           (1990), pp. 814824.</span>

<span class="sd">        .. [#] Yung-Ya Lin et al. A novel detectionestimation scheme for</span>
<span class="sd">           noisy NMR signals: applications to delayed acquisition data.</span>
<span class="sd">           In: J. Magn. Reson. 128.1 (1997), pp. 3041.</span>

<span class="sd">        .. [#] Yingbo Hua. Estimating two-dimensional frequencies by matrix</span>
<span class="sd">           enhancement and matrix pencil. In: [Proceedings] ICASSP 91: 1991</span>
<span class="sd">           International Conference on Acoustics, Speech, and Signal</span>
<span class="sd">           Processing. IEEE. 1991, pp. 30733076.</span>

<span class="sd">        .. [#] Fang-Jiong Chen et al. Estimation of two-dimensional</span>
<span class="sd">           frequencies using modified matrix pencil method. In: IEEE Trans.</span>
<span class="sd">           Signal Process. 55.2 (2007), pp. 718724.</span>

<span class="sd">        .. [#] M. Wax, T. Kailath, Detection of signals by information</span>
<span class="sd">           theoretic criteria, IEEE Transactions on Acoustics, Speech, and</span>
<span class="sd">           Signal Processing 33 (2) (1985) 387392.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_sw_offset</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">trim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trim</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>

        <span class="n">ArgumentChecker</span><span class="p">([(</span><span class="n">trim</span><span class="p">,</span> <span class="s1">&#39;trim&#39;</span><span class="p">,</span> <span class="s1">&#39;int_list&#39;</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="n">trim</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">)</span>
        <span class="c1"># Slice data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">trim</span><span class="p">]</span>

        <span class="n">mpm_info</span> <span class="o">=</span> <span class="n">MatrixPencil</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfo</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">fprint</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">mpm_info</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="c1"># TODO: support for mode</span>
    <span class="c1"># Also look at nlp.nlp.NonlinearProgramming</span>

<div class="viewcode-block" id="Estimator.nonlinear_programming"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.nonlinear_programming">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">nonlinear_programming</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Estimation of signal parameters using nonlinear programming, given</span>
<span class="sd">        an inital guess.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        trim : None, [int], or [int, int], default: None</span>
<span class="sd">            If `trim` is a list, the analysed data will be sliced such that</span>
<span class="sd">            its shape matches `trim`, with the initial points in the signal</span>
<span class="sd">            being retained. If `trim` is `None`, the data will not be</span>
<span class="sd">            sliced. Consider using this in cases where the full signal is</span>
<span class="sd">            large, such that the method takes a very long time, or your PC</span>
<span class="sd">            has insufficient memory to process it.</span>

<span class="sd">        **kwargs</span>
<span class="sd">            Properties of :py:class:`nmrespy.nlp.nlp.NonlinearProgramming`.</span>
<span class="sd">            Valid arguments:</span>

<span class="sd">            * `phase_variance`</span>
<span class="sd">            * `method`</span>
<span class="sd">            * `bound`</span>
<span class="sd">            * `max_iterations`</span>
<span class="sd">            * `amp_thold`</span>
<span class="sd">            * `freq_thold`</span>
<span class="sd">            * `negative_amps`</span>
<span class="sd">            * `fprint`</span>

<span class="sd">            Other keyword arguments that are valid in</span>
<span class="sd">            :py:func:`nmrespy.nlp.nlp.NonlinearProgramming` will be ignored</span>
<span class="sd">            (these are generated internally by the class instance).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        PhaseVarianceAmbiguityError</span>
<span class="sd">            Raised when ``phase_variance`` is set to ``True``, but the user</span>
<span class="sd">            has specified that they do not wish to optimise phases using the</span>
<span class="sd">            ``mode`` argument.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The data analysed will be the following:</span>

<span class="sd">        * If `self.filter_info` is equal to `None`, `self.data` will be</span>
<span class="sd">          analysed</span>
<span class="sd">        * If `self.filter_info` is an instance of</span>
<span class="sd">          :py:class:`nmrespy.freqfilter.FrequencyFilter`,</span>
<span class="sd">          `self.filter_info.filtered_signal` will be analysed.</span>

<span class="sd">        Upon successful completion is this method, `self.result` and</span>
<span class="sd">        `self.errors` will be updated.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`nmrespy.nlp.nlp.NonlinearProgramming`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: include freq threshold</span>

        <span class="n">data</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_sw_offset</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">trim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trim</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">ArgumentChecker</span><span class="p">([(</span><span class="n">trim</span><span class="p">,</span> <span class="s1">&#39;trim&#39;</span><span class="p">,</span> <span class="s1">&#39;int_list&#39;</span><span class="p">)],</span> <span class="n">dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)</span>

        <span class="c1"># Slice data</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">s_</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">t</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">trim</span><span class="p">)]</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>

        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;sfo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span>

        <span class="c1"># nlp_info = NonlinearProgramming(data, x0, sw, **kwargs)</span>
        <span class="n">nlp_info</span> <span class="o">=</span> <span class="n">NonlinearProgramming</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">nlp_info</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="n">nlp_info</span><span class="o">.</span><span class="n">get_errors</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Estimator.write_result"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.write_result">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">write_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves an estimation result to a file in a human-readable format</span>
<span class="sd">        (text, PDF, CSV).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : Properties of :py:func:`nmrespy.write.write_result`.</span>
<span class="sd">            Valid arguments are:</span>

<span class="sd">            * `path`</span>
<span class="sd">            * `description`</span>
<span class="sd">            * `sig_figs`</span>
<span class="sd">            * `sci_lims`</span>
<span class="sd">            * `fmt`</span>
<span class="sd">            * `force_overwrite`</span>
<span class="sd">            * `fprint`</span>

<span class="sd">            Other keyword arguments that are valid in</span>
<span class="sd">            :py:func:`nmrespy.write.write_result` will be ignored (these are</span>
<span class="sd">            generated internally by the class instance).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeIsNoneError</span>
<span class="sd">            If no parameter estimate derived from nonlinear programming</span>
<span class="sd">            is found (see :py:meth:`nonlinear_programming`).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:func:`nmrespy.write.write_result`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Retrieve result</span>
        <span class="c1"># If self.result is None, an error will be raised inside</span>
        <span class="c1"># _check_if_none</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">OR</span><span class="si">}</span><span class="s1">The last action to be applied to the estimation &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;result was not `nonlinear_programming`. You should ensure &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;this is so before saving the result.</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Remove any invalid arguments from kwargs (avoid repetition</span>
        <span class="c1"># in call to nmrespy.write.write_result)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="s1">&#39;integrals&#39;</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;info_headings&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">errors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_errors</span><span class="p">()</span>

        <span class="c1"># Information for experiment info</span>
        <span class="n">sw_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">()</span>
        <span class="n">sw_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">)</span>
        <span class="n">off_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">()</span>
        <span class="n">off_p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">)</span>
        <span class="n">sfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">bf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bf</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nucleus</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">filter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_filter_info</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">filter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">region_h</span> <span class="o">=</span> <span class="nb">filter</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">)</span>
            <span class="n">region_p</span> <span class="o">=</span> <span class="nb">filter</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="s1">&#39;ppm&#39;</span><span class="p">)</span>

        <span class="c1"># Peak integrals</span>
        <span class="n">integrals</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">sig</span><span class="o">.</span><span class="n">oscillator_integral</span><span class="p">(</span><span class="n">osc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">(),</span> <span class="n">sw_h</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">off_h</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">osc</span> <span class="ow">in</span> <span class="n">result</span>
        <span class="p">]</span>

        <span class="c1"># --- Package experiment information ----------------------------</span>
        <span class="n">info_headings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">info</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">sigfig</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Sweep width</span>
            <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Sweep Width (Hz)&#39;</span><span class="p">)</span>
            <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">sw_h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">sw_p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Sweep Width (ppm)&#39;</span><span class="p">)</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">sw_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>

            <span class="c1"># Offset</span>
            <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Transmitter Offset (Hz)&#39;</span><span class="p">)</span>
            <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">off_h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>
            <span class="k">if</span> <span class="n">off_p</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Transmitter Offset (ppm)&#39;</span><span class="p">)</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">off_p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>

            <span class="c1"># Transmitter frequency</span>
            <span class="k">if</span> <span class="n">sfo</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Transmitter Frequency (MHz)&#39;</span><span class="p">)</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">sfo</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>

            <span class="c1"># Basic frequency</span>
            <span class="k">if</span> <span class="n">bf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Basic Frequency (MHz)&#39;</span><span class="p">)</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">bf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)))</span>

            <span class="c1"># Nuclei</span>
            <span class="k">if</span> <span class="n">nuc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Nucleus&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;fmt&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fmt&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;pdf&#39;</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">latex_nucleus</span><span class="p">(</span><span class="n">nuc</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nuc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Region</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">region_h</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)</span><span class="si">}</span><span class="s1"> -&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">region_h</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
                <span class="n">info</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">region_p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)</span><span class="si">}</span><span class="s1"> -&#39;</span>
                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">significant_figures</span><span class="p">(</span><span class="n">region_p</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigfig</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Filter region (Hz):&#39;</span><span class="p">)</span>
                <span class="n">info_headings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;Filter region (ppm):&#39;</span><span class="p">)</span>

            <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># TODO</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TwoDimUnsupportedError</span><span class="p">()</span>

        <span class="n">write_result</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="n">errors</span><span class="p">,</span> <span class="n">integrals</span><span class="o">=</span><span class="n">integrals</span><span class="p">,</span>
                     <span class="n">info_headings</span><span class="o">=</span><span class="n">info_headings</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span><span class="p">,</span> <span class="n">sfo</span><span class="o">=</span><span class="n">sfo</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.plot_result"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.plot_result">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">plot_result</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produces a figure of an estimation result.</span>

<span class="sd">        The figure consists of the original data, in the Fourier domain,</span>
<span class="sd">        along with each oscillator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs : Properties of :py:func:`nmrespy.write.write_result`.</span>
<span class="sd">            Valid arguments are:</span>

<span class="sd">            * `shifts_unit`</span>
<span class="sd">            * `plot_residual`</span>
<span class="sd">            * `plot_model`</span>
<span class="sd">            * `residual_shift`</span>
<span class="sd">            * `model_shift`</span>
<span class="sd">            * `data_color`</span>
<span class="sd">            * `oscillator_colors`</span>
<span class="sd">            * `residual_color`</span>
<span class="sd">            * `model_color`</span>
<span class="sd">            * `labels`</span>
<span class="sd">            * `stylesheet`</span>

<span class="sd">            Other keyword arguments that are valid in</span>
<span class="sd">            :py:func:`nmrespy.plot.plot_result` will be ignored (these are</span>
<span class="sd">            generated internally by the class instance).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeIsNoneError</span>
<span class="sd">            If no parameter estimate derived from nonlinear programming</span>
<span class="sd">            is found (see :py:meth:`nonlinear_programming`).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:func:`nmrespy.plot.plot_result`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">OR</span><span class="si">}</span><span class="s1">The last action to be applied to the estimation &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;result was not `nonlinear_programming`. You should ensure &#39;</span>
                <span class="sa">f</span><span class="s1">&#39;this is so before plotting the result.</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span>
        <span class="c1"># Check dim is valid (only 1D data supported so far)</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">TwoDimUnsupportedError</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sfo&#39;</span><span class="p">,</span> <span class="s1">&#39;nuceleus&#39;</span><span class="p">,</span> <span class="s1">&#39;region&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shifts_unit&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;shifts_unit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">unit</span> <span class="o">=</span> <span class="s1">&#39;ppm&#39;</span>

        <span class="k">return</span> <span class="n">plot_result</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(),</span> <span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">(),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_offset</span><span class="p">(),</span> <span class="n">sfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">nucleus</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_nucleus</span><span class="p">(</span><span class="n">kill</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">region</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_filter_info</span><span class="p">()</span><span class="o">.</span><span class="n">get_region</span><span class="p">(</span><span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Estimator.add_oscillators"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.add_oscillators">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">add_oscillators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oscillators</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds new oscillators an estimation result.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oscillators : numpy.ndarray</span>
<span class="sd">            An array of the new oscillator(s) to add to the array.</span>
<span class="sd">            *NB* `oscillators` should always be a two-dimensional array,</span>
<span class="sd">            even if only one oscillator is being added:</span>

<span class="sd">            .. code:: python3</span>

<span class="sd">               &gt;&gt;&gt; oscillators = np.array([[a, , f, ]]) # 1D</span>
<span class="sd">               &gt;&gt;&gt; oscillators = np.array([[a, , f1, f2, 1, 2]]) # 2D</span>
<span class="sd">               &gt;&gt;&gt; # or, equivalently:</span>
<span class="sd">               &gt;&gt;&gt; oscillators = np.insert_axis(</span>
<span class="sd">               ...      np.array([a, , f, ]), axis=1</span>
<span class="sd">               ... ) # 1D</span>
<span class="sd">               &gt;&gt;&gt; oscillators = np.insert_axis(</span>
<span class="sd">               ...      np.array([a, , f1, f2, 1, 2]), axis=1</span>
<span class="sd">               ... ) # 2D</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ArgumentChecker</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">oscillators</span><span class="p">,</span> <span class="s1">&#39;oscillators&#39;</span><span class="p">,</span> <span class="s1">&#39;parameter&#39;</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">(),</span>
        <span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="n">new_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">oscillators</span><span class="p">))</span>
        <span class="c1"># Order according to frequency</span>
        <span class="n">new_result</span> <span class="o">=</span> <span class="n">new_result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">new_result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])]</span>
        <span class="c1"># Assign new result to nlp_info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">new_result</span>
        <span class="c1"># User has manually edited the result after estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Estimator.remove_oscillators"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.remove_oscillators">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">remove_oscillators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes the oscillators corresponding to ``indices``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : list</span>
<span class="sd">            A list of indices corresponding to the oscillators to be</span>
<span class="sd">            removed. The elements of `indices` should be ints that</span>
<span class="sd">            are in ``range(result.shape[0])``, where `result` is the</span>
<span class="sd">            current estimation result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ArgumentChecker</span><span class="p">([(</span><span class="n">indices</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">)])</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">Invalid index in `indices`</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># User has manually edited the result after estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Estimator.merge_oscillators"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.merge_oscillators">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">merge_oscillators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Merges the oscillators corresponding to `indices`.</span>

<span class="sd">        Removes the osccilators specified, and constructs a single new</span>
<span class="sd">        oscillator with a cumulative amplitude, and averaged phase,</span>
<span class="sd">        frequency and damping.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : list, tuple or numpy.ndarray</span>
<span class="sd">            A list of indices corresponding to the oscillators to be</span>
<span class="sd">            merged. The elements of `indices` should be ints that</span>
<span class="sd">            are in ``range(result.shape[0])``, where `result` is the</span>
<span class="sd">            current estimation result.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Assuming that an estimation result contains a subset of oscillators</span>
<span class="sd">        denoted by indices :math:`\\{m_1, m_2, \\cdots, m_J\\}`, where</span>
<span class="sd">        :math:`J \\leq M`, the new oscillator formed by the merging of the</span>
<span class="sd">        oscillator subset will possess the following parameters:</span>

<span class="sd">            * :math:`a_{\\mathrm{new}} = \\sum_{i=1}^J a_{m_i}`</span>
<span class="sd">            * :math:`\\phi_{\\mathrm{new}} = \\frac{1}{J} \\sum_{i=1}^J</span>
<span class="sd">              \\phi_{m_i}`</span>
<span class="sd">            * :math:`f_{\\mathrm{new}} = \\frac{1}{J} \\sum_{i=1}^J f_{m_i}`</span>
<span class="sd">            * :math:`\\eta_{\\mathrm{new}} = \\frac{1}{J} \\sum_{i=1}^J</span>
<span class="sd">              \\eta_{m_i}`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ArgumentChecker</span><span class="p">([(</span><span class="n">indices</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">)])</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">OR</span><span class="si">}</span><span class="s1">`indices` should contain at least two elements.&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;No merging will happen.</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">Invalid index in `indices`</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
                <span class="p">)</span>

        <span class="n">to_merge</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="c1"># Sum amps, phases, freqs and damping over the oscillators</span>
        <span class="c1"># to be merged.</span>
        <span class="c1"># keepdims ensures that the final array is [[a, , f, ]]</span>
        <span class="c1"># rather than [a, , f, ]</span>
        <span class="n">new_osc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">to_merge</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Get mean for phase, frequency and damping</span>
        <span class="n">new_osc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">new_osc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
        <span class="c1"># wrap phase</span>
        <span class="n">new_osc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">new_osc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">new_osc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>

        <span class="c1"># User has manually edited the result after estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="c1"># TODO make 2D compatible</span>
<div class="viewcode-block" id="Estimator.split_oscillator"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.split_oscillator">[docs]</a>    <span class="nd">@logger</span>
    <span class="k">def</span> <span class="nf">split_oscillator</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">separation_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="n">split_number</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">amp_ratio</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Splits the oscillator corresponding to `index`.</span>

<span class="sd">        Removes an oscillator, and incorporates two or more oscillators</span>
<span class="sd">        whose cumulative amplitudes match that of the removed oscillator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int</span>
<span class="sd">            Array index of the oscilator to be split.</span>

<span class="sd">        separation_frequency : float, or None default: None</span>
<span class="sd">            The frequency separation given to adjacent oscillators formed</span>
<span class="sd">            from the splitting. If `None`, the splitting will be set to</span>
<span class="sd">            ``sw / n`` where `sw` is the sweep width and `n` is the number</span>
<span class="sd">            of points in the data.</span>

<span class="sd">        unit : &#39;hz&#39; or &#39;ppm&#39;, default: &#39;hz&#39;</span>
<span class="sd">            The unit of `separation_frequency`.</span>

<span class="sd">        split_number: int, default: 2</span>
<span class="sd">            The number of peaks to split the oscillator into.</span>

<span class="sd">        amp_ratio: list or None, default: None</span>
<span class="sd">            The ratio of amplitudes to be fulfilled by the newly formed</span>
<span class="sd">            peaks. If a list, ``len(amp_ratio) == split_number`` must be</span>
<span class="sd">            satisfied. The first element will relate to the highest</span>
<span class="sd">            frequency oscillator constructed, and the last element will</span>
<span class="sd">            relate to the lowest frequency oscillator constructed. If `None`,</span>
<span class="sd">            all oscillators will be given equal amplitudes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get separation_frequency in correct units</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">InvalidUnitError</span><span class="p">(</span><span class="s1">&#39;hz&#39;</span><span class="p">,</span> <span class="s1">&#39;ppm&#39;</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_result</span><span class="p">(</span><span class="n">freq_unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Of form: [a, , f, ] (i.e. 1D array)</span>
            <span class="n">osc</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">index should be an int in range(&#39;</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1">)</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># --- Determine frequencies --------------------------------------</span>
        <span class="k">if</span> <span class="n">separation_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">separation_frequency</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sw</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_n</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
                <span class="n">separation_frequency</span> <span class="o">=</span> <span class="n">separation_frequency</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Highest frequency of all the new oscillators</span>
        <span class="n">max_freq</span> <span class="o">=</span> <span class="n">osc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">((</span><span class="n">split_number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">separation_frequency</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Array of all frequencies (lowest to highest)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">max_freq</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="n">separation_frequency</span>
                 <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">split_number</span><span class="p">)]</span>

        <span class="c1"># --- Determine amplitudes ---------------------------------------</span>
        <span class="k">if</span> <span class="n">amp_ratio</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">amp_ratio</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">split_number</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">amp_ratio</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">`amp_ratio` should be None or a list</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">amp_ratio</span><span class="p">)</span> <span class="o">!=</span> <span class="n">split_number</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">The length of `amp_ratio` should equal&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; `split_number`</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Scale amplitude ratio values such that their sum is 1</span>
        <span class="n">amp_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">amp_ratio</span><span class="p">)</span>
        <span class="n">amp_ratio</span> <span class="o">=</span> <span class="n">amp_ratio</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">amp_ratio</span><span class="p">)</span>

        <span class="c1"># Obtain amplitude values</span>
        <span class="n">amps</span> <span class="o">=</span> <span class="n">osc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">amp_ratio</span>

        <span class="c1"># --- Generate array of new oscillators --------------------------</span>
        <span class="n">new_oscs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">split_number</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dim</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">new_oscs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">amps</span>
        <span class="n">new_oscs</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">freqs</span>
        <span class="n">new_oscs</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">osc</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">split_number</span>
        <span class="n">new_oscs</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">osc</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span> <span class="o">*</span> <span class="n">split_number</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">new_oscs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;ppm&#39;</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sfo</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])]</span>

        <span class="c1"># User has manually edited the result after estimation.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Estimator.save_logfile"><a class="viewcode-back" href="../../references/core.html#nmrespy.core.Estimator.save_logfile">[docs]</a>    <span class="k">def</span> <span class="nf">save_logfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="s1">&#39;./nmrespy_log&#39;</span><span class="p">,</span> <span class="n">force_overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Saves log file of class instance usage to a specified path.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str, default: &#39;./nmrespy_log&#39;</span>
<span class="sd">            The path to save the file to. DO NOT INCLUDE A FILE EXTENSION.</span>
<span class="sd">            `.log` will be added automatically.</span>

<span class="sd">        force_overwrite : bool. default: False</span>
<span class="sd">            Defines behaviour if ``f&#39;{path}.log&#39;`` already exists:</span>

<span class="sd">            * If `force_overwrite` is set to `False`, the user will be prompted</span>
<span class="sd">              if they are happy overwriting the current file.</span>
<span class="sd">            * If `force_overwrite` is set to `True`, the current file will be</span>
<span class="sd">              overwritten without prompt.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ArgumentChecker</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">,</span> <span class="s1">&#39;str&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="n">force_overwrite</span><span class="p">,</span> <span class="s1">&#39;force_overwrite&#39;</span><span class="p">,</span> <span class="s1">&#39;bool&#39;</span><span class="p">),</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Get full path and extend .log extension</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;.log&#39;</span><span class="p">)</span>
        <span class="c1"># Check path is valid (check directory exists, ask user if they are</span>
        <span class="c1"># happy overwriting if file already exists).</span>
        <span class="n">pathres</span> <span class="o">=</span> <span class="n">PathManager</span><span class="p">(</span>
            <span class="n">path</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">parent</span>
        <span class="p">)</span><span class="o">.</span><span class="n">check_file</span><span class="p">(</span><span class="n">force_overwrite</span><span class="p">)</span>
        <span class="c1"># Valid path, we are good to proceed</span>
        <span class="k">if</span> <span class="n">pathres</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="c1"># Overwrite denied by the user. Exit the program</span>
        <span class="k">elif</span> <span class="n">pathres</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">exit</span><span class="p">()</span>
        <span class="c1"># pathres == 2: Directory specified doesn&#39;t exist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s1">The directory implied by path does not&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; exist</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">cols</span><span class="o">.</span><span class="n">G</span><span class="si">}</span><span class="s1">Log file succesfully saved to&#39;</span>
                <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="si">}{</span><span class="n">cols</span><span class="o">.</span><span class="n">END</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="c1"># trouble writing to file...</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">e</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">NMR-EsPy  documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">nmrespy.core</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Simon Hulse &amp; Mohammadali Foroozandeh.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>