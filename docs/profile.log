FUNCTION  <SNR>87_HasAnyKey()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:479
Called 12 times
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
   24              0.000081   for key in a:keys
   12              0.000069     if has_key( a:dict, key )
                                  return 1
   12              0.000014     endif
   24              0.000040   endfor
   12              0.000017   return 0

FUNCTION  <SNR>34_filename()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:236
Called 3 times
Total time:   0.000405
 Self time:   0.000071

count  total (s)   self (s)
    3   0.000398   0.000064   return fnamemodify(s:abs_path(a:bufnr, 0), ':t')

FUNCTION  ale#command#SetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:34
Called 7 times
Total time:   0.000120
 Self time:   0.000058

count  total (s)   self (s)
    7   0.000100   0.000038     call ale#command#InitData(a:buffer)
    7              0.000017     let s:buffer_data[a:buffer].cwd = a:cwd

FUNCTION  <SNR>91_ShouldOpen()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:41
Called 7 times
Total time:   0.000188
 Self time:   0.000093

count  total (s)   self (s)
    7   0.000140   0.000045     let l:val = ale#Var(a:buffer, 'open_list')
    7              0.000019     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    7              0.000022     return l:val > 0 ? a:loclist_len >= l:val : l:val is# 'on_save' && l:saved

FUNCTION  ale#job#IsRunning()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:318
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000006     if has('nvim')
                                    try
                                        " In NeoVim, if the job isn't running, jobpid() will throw.
                                        call jobpid(a:job_id)
                            
                                        return 1
                                    catch
                                    endtry
    2              0.000005     elseif has_key(s:job_map, a:job_id)
                                    let l:job = s:job_map[a:job_id].job
                            
                                    return job_status(l:job) is# 'run'
    2              0.000000     endif
                            
    2              0.000002     return 0

FUNCTION  <SNR>90_UpdateLineNumbers()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:282
Called 7 times
Total time:   1.220964
 Self time:   0.467053

count  total (s)   self (s)
    7              0.000020     let l:line_map = {}
    7              0.000012     let l:line_numbers_changed = 0
                            
20487              0.021009     for [l:line, l:sign_id, l:name] in a:current_sign_list
20480              0.037400         let l:line_map[l:sign_id] = l:line
20487              0.008236     endfor
                            
33866              0.020287     for l:item in a:loclist
33859              0.032750         if l:item.bufnr == a:buffer
33859              0.090042             let l:lnum = get(l:line_map, get(l:item, 'sign_id', 0), 0)
                            
33859              0.038994             if l:lnum && l:item.lnum != l:lnum
 7750              0.007387                 let l:item.lnum = l:lnum
 7750              0.008197                 let l:line_numbers_changed = 1
33859              0.012632             endif
33859              0.012161         endif
33866              0.013758     endfor
                            
                                " When the line numbers change, sort the list again
    7              0.000009     if l:line_numbers_changed
    2   0.868630   0.114719         call sort(a:loclist, 'ale#util#LocItemCompare')
    7              0.000004     endif

FUNCTION  <SNR>174_indent_tikz()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:296
Called 1 time
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000015   if !has_key(b:vimtex.packages, 'tikz') | return 0 | endif
                            
                              let l:env_pos = vimtex#env#is_inside('tikzpicture')
                              if l:env_pos[0] > 0 && l:env_pos[0] < a:lnum
                                let l:prev_starts = a:prev =~# s:tikz_commands
                                let l:prev_stops  = a:prev =~# ';\s*$'
                            
                                " Increase indent on tikz command start
                                if l:prev_starts && ! l:prev_stops
                                  return s:sw
                                endif
                            
                                " Decrease indent on tikz command end, i.e. on semicolon
                                if ! l:prev_starts && l:prev_stops
                                  let l:context = join(getline(l:env_pos[0], a:lnum-1), '')
                                  return -s:sw*(l:context =~# s:tikz_commands)
                                endif
                              endif
                            
                              return 0

FUNCTION  <SNR>74_HandleExit()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:151
Called 7 times
Total time:  10.993605
 Self time:   0.006646

count  total (s)   self (s)
    7              0.000027     let l:buffer_info = get(g:ale_buffer_info, a:buffer)
                            
    7              0.000010     if empty(l:buffer_info)
                                    return
    7              0.000001     endif
                            
    7              0.000010     let l:linter = a:job_info.linter
    7              0.000010     let l:executable = a:job_info.executable
                            
                                " Remove this job from the list.
    7   0.000098   0.000043     call ale#engine#MarkLinterInactive(l:buffer_info, l:linter.name)
                            
                                " Stop here if we land in the handle for a job completing if we're in
                                " a sandbox.
    7   0.000109   0.000027     if ale#util#InSandbox()
                                    return
    7              0.000005     endif
                            
    7              0.000048     if has('nvim') && !empty(a:output) && empty(a:output[-1])
                                    call remove(a:output, -1)
    7              0.000001     endif
                            
    7              0.000003     try
    7   0.341005   0.000080         let l:loclist = ale#util#GetFunction(l:linter.callback)(a:buffer, a:output)
                                " Handle the function being unknown, or being deleted.
                                catch /E700/
                                    let l:loclist = []
    7              0.000006     endtry
                            
    7  10.652181   0.006284     call ale#engine#HandleLoclist(l:linter.name, a:buffer, l:loclist, 0)

FUNCTION  gitgutter#utility#system()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:91
Called 6 times
Total time:   0.075742
 Self time:   0.002157

count  total (s)   self (s)
    6   0.000761   0.000106   call gitgutter#debug#log(a:cmd, a:000)
                            
    6   0.000752   0.000112   call s:use_known_shell()
    6   0.072560   0.001493   silent let output = (a:0 == 0) ? system(a:cmd) : system(a:cmd, a:1)
    6   0.001572   0.000349   call s:restore_shell()
                            
    6              0.000041   return output

FUNCTION  <SNR>174_indent_envs()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:190
Called 1 time
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
    1              0.000004   let l:ind = 0
                            
                              " First for general environments
    1              0.000026   let l:ind += s:sw*(    a:prev_line =~# s:envs_begin && a:prev_line !~# s:envs_end && a:prev_line !~# s:envs_ignored)
    1              0.000004   let l:xx = l:ind
    1              0.000026   let l:ind -= s:sw*(    a:line !~# s:envs_begin && a:line =~# s:envs_end && a:line !~# s:envs_ignored)
                            
    1              0.000003   return l:ind

FUNCTION  ale#linter#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:373
Called 3 times
Total time:   0.001709
 Self time:   0.000973

count  total (s)   self (s)
    3              0.000029     let l:possibly_duplicated_linters = []
                            
                                " Handle dot-separated filetypes.
    6              0.000053     for l:original_filetype in split(a:original_filetypes, '\.')
    3   0.000360   0.000048         let l:filetype = ale#linter#ResolveFiletype(l:original_filetype)
    3   0.000208   0.000041         let l:linter_names = s:GetLinterNames(l:original_filetype)
    3   0.000284   0.000027         let l:all_linters = ale#linter#GetAll(l:filetype)
    3              0.000007         let l:filetype_linters = []
                            
    3              0.000017         if type(l:linter_names) is v:t_string && l:linter_names is# 'all'
    3              0.000008             let l:filetype_linters = l:all_linters
                                    elseif type(l:linter_names) is v:t_list
                                        " Select only the linters we or the user has specified.
                                        for l:linter in l:all_linters
                                            let l:name_list = [l:linter.name] + l:linter.aliases
                            
                                            for l:name in l:name_list
                                                if index(l:linter_names, l:name) >= 0
                                                    call add(l:filetype_linters, l:linter)
                                                    break
                                                endif
                                            endfor
                                        endfor
    3              0.000004         endif
                            
    3              0.000016         call extend(l:possibly_duplicated_linters, l:filetype_linters)
    6              0.000008     endfor
                            
    3              0.000006     let l:name_list = []
    3              0.000007     let l:combined_linters = []
                            
                                " Make sure we override linters so we don't get two with the same name,
                                " like 'eslint' for both 'javascript' and 'typescript'
                                "
                                " Note that the reverse calls here modify the List variables.
   33              0.000052     for l:linter in reverse(l:possibly_duplicated_linters)
   30              0.000118         if index(l:name_list, l:linter.name) < 0
   30              0.000095             call add(l:name_list, l:linter.name)
   30              0.000090             call add(l:combined_linters, l:linter)
   30              0.000028         endif
   33              0.000025     endfor
                            
    3              0.000011     return reverse(l:combined_linters)

FUNCTION  <lambda>199()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.582900
 Self time:   0.000017

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <SNR>87_DisableOnLargeFile()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:464
Called 12 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
   12              0.000055   if exists( 'b:ycm_largefile' )
   12              0.000025     return b:ycm_largefile
                              endif
                            
                              let threshold = g:ycm_disable_for_files_larger_than_kb * 1024
                              let b:ycm_largefile = threshold > 0 && getfsize( expand( a:buffer ) ) > threshold
                              if b:ycm_largefile
                                py3 vimsupport.PostVimMessage( 'YouCompleteMe is disabled in this buffer;' + ' the file exceeded the max size (see YCM options).' )
                              endif
                              return b:ycm_largefile

FUNCTION  <SNR>87_OnTextChangedInsertMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:836
Called 1 time
Total time:   0.006771
 Self time:   0.000216

count  total (s)   self (s)
    1   0.000074   0.000005   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000001   endif
                            
    1              0.000002   if a:popup_is_visible && !s:last_char_inserted_by_user
                                " If the last "input" wasn't from a user typing (i.e. didn't come from
                                " InsertCharPre, then ignore this change in the text. This prevents ctrl-n
                                " or tab from causing us to re-filter the list based on the now-selected
                                " item.
                                return
    1              0.000000   endif
                            
    1              0.000003   let s:current_cursor_position = getpos( '.' )
    1              0.000001   if s:completion_stopped
                                let s:completion_stopped = 0
                                let s:completion = s:default_completion
                                return
    1              0.000000   endif
                            
    1   0.002435   0.000008   call s:IdentifierFinishedOperations()
                            
                              " We have to make sure we correctly leave semantic mode even when the user
                              " inserts something like a "operator[]" candidate string which fails
                              " CurrentIdentifierFinished check.
    1              0.000003   if s:force_semantic && !py3eval( 'base.LastEnteredCharIsIdentifierChar()' )
                                let s:force_semantic = 0
    1              0.000016   endif
                            
    1   0.004082   0.000023   if get( b:, 'ycm_completing' ) && ( g:ycm_auto_trigger || s:force_semantic ) && !s:InsideCommentOrStringAndShouldStop() && !s:OnBlankLine()
                                " The call to s:Complete here is necessary, to minimize flicker when we
                                " close the pum on every keypress. In that case, we try to quickly show it
                                " again with whatver the latest completion result is. When using complete(),
                                " we don't need to do this, as we only close the pum when there are no
                                " completions. However, it's still useful as we don't want Vim's filtering
                                " to _ever_ apply. Examples of when this is problematic is when typing some
                                " keys to filter (that are not a prefix of the completion), then deleting a
                                " character. Normally Vim would re-filter based on the new "query", but we
                                " don't want that.
                                call s:Complete()
                                call s:RequestCompletion()
                            
                                call s:UpdateSignatureHelp()
                                call s:RequestSignatureHelp()
    1              0.000003   endif
                            
    1              0.000079   py3 ycm_state.OnCursorMoved()
                            
    1              0.000007   if g:ycm_autoclose_preview_window_after_completion
                                call s:ClosePreviewWindowIfNeeded()
    1              0.000002   endif

FUNCTION  ale#highlight#CreatePositions()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:68
Called 27174 times
Total time:   0.111269
 Self time:   0.111269

count  total (s)   self (s)
27174              0.030808     if a:line >= a:end_line
                                    " For single lines, just return the one position.
27174              0.064970         return [[[a:line, a:col, a:end_col - a:col + 1]]]
                                endif
                            
                                " Get positions from the first line at the first column, up to a large
                                " integer for highlighting up to the end of the line, followed by
                                " the lines in-between, for highlighting entire lines, and
                                " a highlight for the last line, up to the end column.
                                let l:all_positions =   [[a:line, a:col, s:MAX_COL_SIZE]]   + range(a:line + 1, a:end_line - 1)   + [[a:end_line, 1, a:end_col]]
                            
                                return map(   range(0, len(l:all_positions) - 1, s:MAX_POS_VALUES),   'l:all_positions[v:val : v:val + s:MAX_POS_VALUES - 1]',)

FUNCTION  <SNR>87_InsideCommentOrStringAndShouldStop()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:960
Called 1 time
Total time:   0.000032
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000023   0.000005   let retval = s:InsideCommentOrString()
    1              0.000002   let inside_comment = retval == 1
    1              0.000001   let inside_string = retval == 2
                            
    1              0.000002   if inside_comment && g:ycm_complete_in_comments || inside_string && g:ycm_complete_in_strings
                                return 0
    1              0.000001   endif
                            
    1              0.000001   return retval

FUNCTION  <SNR>96_reset_summary()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:24
Called 3 times
Total time:   0.000421
 Self time:   0.000241

count  total (s)   self (s)
    3   0.000411   0.000231   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>97_highlight_name_for_change()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:234
Called 21 times
Total time:   0.000713
 Self time:   0.000713

count  total (s)   self (s)
   21              0.000152   if a:text ==# 'added'
    3              0.000011     return 'GitGutterLineAdded'
   18              0.000096   elseif a:text ==# 'removed'
                                return 'GitGutterLineRemoved'
   18              0.000093   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
   18              0.000090   elseif a:text ==# 'modified'
   15              0.000054     return 'GitGutterLineModified'
    3              0.000012   elseif a:text ==# 'modified_removed'
    3              0.000009     return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  <SNR>87_OnBlankLine()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:974
Called 1 time
Total time:   0.004027
 Self time:   0.004027

count  total (s)   self (s)
    1              0.004026   return py3eval( 'not vim.current.line or vim.current.line.isspace()' )

FUNCTION  <SNR>174_clean_line()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:92
Called 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000050   return substitute(a:line, '\s*\\\@<!%.*', '', '')

FUNCTION  ale#highlight#RemoveHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:92
Called 7 times
Total time:   0.203722
 Self time:   0.203722

count  total (s)   self (s)
    7              0.000008     if s:has_nvim_highlight
                                    call ale#highlight#nvim_buf_clear_namespace(bufnr(''), s:ns_id, 0, -1)
    7              0.000004     else
27181              0.042347         for l:match in getmatches()
27174              0.098104             if l:match.group =~? '\v^ALE(Style)?(Error|Warning|Info)(Line)?$'
27174              0.037638                 call matchdelete(l:match.id)
27174              0.010063             endif
27181              0.011263         endfor
    7              0.000004     endif

FUNCTION  <SNR>91_FixList()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:76
Called 7 times
Total time:   1.519457
 Self time:   0.422240

count  total (s)   self (s)
    7   0.000118   0.000030     let l:format = ale#Var(a:buffer, 'loclist_msg_format')
    7              0.000008     let l:new_list = []
                            
32627              0.022310     for l:item in a:list
32620              0.076985         let l:fixed_item = copy(l:item)
                            
32620   1.240318   0.143189         let l:fixed_item.text = ale#GetLocItemMessage(l:item, l:format)
                            
32620              0.031233         if l:item.bufnr == -1
                                        " If the buffer number is invalid, remove it.
                                        call remove(l:fixed_item, 'bufnr')
32620              0.013016         endif
                            
32620              0.051205         call add(l:new_list, l:fixed_item)
32627              0.015364     endfor
                            
    7              0.000007     return l:new_list

FUNCTION  ale#handlers#unix#HandleAsWarning()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/unix.vim:24
Called 1 time
Total time:   0.001022
 Self time:   0.000005

count  total (s)   self (s)
    1   0.001022   0.000005     return s:HandleUnixFormat(a:buffer, a:lines, 'W')

FUNCTION  ale#sign#FindCurrentSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:250
Called 7 times
Total time:   0.175300
 Self time:   0.003543

count  total (s)   self (s)
    7              0.000021     if exists('*sign_getplaced')
    7   0.175273   0.003516         return ale#sign#ParseSignsWithGetPlaced(a:buffer)
                                else
                                    let l:line_list = ale#sign#ReadSigns(a:buffer)
                            
                                    return ale#sign#ParseSigns(l:line_list)
                                endif

FUNCTION  <SNR>75_GatherOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:281
Called 14440 times
Total time:   0.027972
 Self time:   0.027972

count  total (s)   self (s)
14440              0.025887     call add(a:line_list, a:line)

FUNCTION  ale#handlers#cspell#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/cspell.vim:5
Called 3 times
Total time:   0.001402
 Self time:   0.000025

count  total (s)   self (s)
    3   0.001397   0.000020     return ale#path#FindExecutable(a:buffer,    'cspell', [        'node_modules/.bin/cspell',        'node_modules/cspell/bin.js',    ])

FUNCTION  <SNR>87_StopPoller()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:584
Called 6 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    6              0.000021   call timer_stop( a:poller.id )
    6              0.000018   let a:poller.id = -1

FUNCTION  <SNR>87_OnTextChangedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:827
Called 2 times
Total time:   0.003093
 Self time:   0.000056

count  total (s)   self (s)
    2   0.000332   0.000031   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    2              0.000002   endif
                            
    2   0.002756   0.000020   call s:OnFileReadyToParse()

FUNCTION  VimtexIndent()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:37
Called 1 time
Total time:   0.001960
 Self time:   0.000340

count  total (s)   self (s)
    1              0.000020   let s:sw = shiftwidth()
                            
    1   0.000431   0.000037   let [l:prev_lnum, l:prev_line] = s:get_prev_lnum(prevnonblank(a:lnum - 1))
    1              0.000012   if l:prev_lnum == 0 | return indent(a:lnum) | endif
    1   0.000035   0.000020   let l:line = s:clean_line(getline(a:lnum))
                            
                              " Check for verbatim modes
    1   0.000197   0.000016   if s:is_verbatim(l:line, a:lnum)
                                return empty(l:line) ? indent(l:prev_lnum) : indent(a:lnum)
    1              0.000002   endif
                            
                              " Use previous indentation for comments
    1              0.000011   if l:line =~# '^\s*%'
                                return indent(a:lnum)
    1              0.000002   endif
                            
                              " Align on ampersands
    1   0.000201   0.000024   let l:ind = s:indent_amps.check(a:lnum, l:line, l:prev_lnum, l:prev_line)
    1              0.000008   if s:indent_amps.finished | return l:ind | endif
    1              0.000005   let l:prev_lnum = s:indent_amps.prev_lnum
    1              0.000005   let l:prev_line = s:indent_amps.prev_line
                            
                              " Indent environments, delimiters, and conditionals
    1   0.000093   0.000024   let l:ind += s:indent_envs(l:line, l:prev_line)
    1   0.000122   0.000027   let l:ind += s:indent_items(l:line, a:lnum, l:prev_line, l:prev_lnum)
    1   0.000583   0.000022   let l:ind += s:indent_delims(l:line, a:lnum, l:prev_line, l:prev_lnum)
    1   0.000141   0.000028   let l:ind += s:indent_conditionals(l:line, a:lnum, l:prev_line, l:prev_lnum)
                            
                              " Indent tikz commands
    1              0.000004   if g:vimtex_indent_tikz_commands
    1   0.000040   0.000025     let l:ind += s:indent_tikz(l:prev_lnum, l:prev_line)
    1              0.000002   endif
                            
    1              0.000005   return l:ind < 0 ? 0 : l:ind

FUNCTION  <SNR>87_AllowedToCompleteInBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:493
Called 12 times
Total time:   0.001634
 Self time:   0.001187

count  total (s)   self (s)
   12              0.000096   let buftype = getbufvar( a:buffer, '&buftype' )
                            
   12              0.000065   if has_key( s:buftype_blacklist, buftype )
                                return 0
   12              0.000011   endif
                            
   12              0.000070   let filetype = getbufvar( a:buffer, '&filetype' )
   12              0.000048   if empty( filetype )
                                let filetype = 'ycm_nofiletype'
   12              0.000012   endif
                            
   12              0.000158   let whitelist_allows = type( g:ycm_filetype_whitelist ) != v:t_dict || has_key( g:ycm_filetype_whitelist, '*' ) || s:HasAnyKey( g:ycm_filetype_whitelist, split( filetype, '\.' ) )
   12   0.000599   0.000250   let blacklist_allows = type( g:ycm_filetype_blacklist ) != v:t_dict || !s:HasAnyKey( g:ycm_filetype_blacklist, split( filetype, '\.' ) )
                            
   12              0.000042   let allowed = whitelist_allows && blacklist_allows
                            
   12   0.000232   0.000134   if !allowed || s:DisableOnLargeFile( a:buffer )
                                return 0
   12              0.000016   endif
                            
   12              0.000019   if allowed
   12              0.000083     let s:previous_allowed_buffer_number = bufnr( a:buffer )
   12              0.000011   endif
   12              0.000020   return allowed

FUNCTION  <SNR>174_is_verbatim()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:97
Called 2 times
Total time:   0.000428
 Self time:   0.000087

count  total (s)   self (s)
    2   0.000427   0.000086   return a:line !~# s:verbatim_re_envdelim && vimtex#env#is_inside(s:verbatim_re_list)[0]

FUNCTION  <SNR>86_setup_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:169
Called 6 times
Total time:   0.031725
 Self time:   0.000243

count  total (s)   self (s)
    6   0.000627   0.000115   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
    3   0.031074   0.000104   return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  ale#highlight#UpdateHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:156
Called 7 times
Total time:   2.180248
 Self time:   0.598407

count  total (s)   self (s)
    7              0.000033     let l:item_list = get(b:, 'ale_enabled', 1) && g:ale_enabled   ? get(b:, 'ale_highlight_items', [])   : []
                            
    7   0.203761   0.000039     call ale#highlight#RemoveHighlights()
                            
27181              0.020456     for l:item in l:item_list
27174              0.031454         if l:item.type is# 'W'
27174              0.048595             if get(l:item, 'sub_type', '') is# 'style'
                                            let l:group = 'ALEStyleWarning'
27174              0.011242             else
27174              0.025829                 let l:group = 'ALEWarning'
27174              0.011310             endif
                                    elseif l:item.type is# 'I'
                                        let l:group = 'ALEInfo'
                                    elseif get(l:item, 'sub_type', '') is# 'style'
                                        let l:group = 'ALEStyleError'
                                    else
                                        let l:group = 'ALEError'
27174              0.010858         endif
                            
27174              0.137770         let l:range = {   'lnum': l:item.lnum,   'col': l:item.col,   'end_lnum': get(l:item, 'end_lnum', l:item.lnum),   'end_col': get(l:item, 'end_col', l:item.col)}
                            
27174   1.508048   0.129929         call s:highlight_range(l:item.bufnr, l:range, l:group)
27181              0.012547     endfor
                            
                                " If highlights are enabled and signs are not enabled, we should still
                                " offer line highlights by adding a separate set of highlights.
    7              0.000007     if !g:ale_set_signs
                                    let l:available_groups = {   'ALEWarningLine': hlexists('ALEWarningLine'),   'ALEInfoLine': hlexists('ALEInfoLine'),   'ALEErrorLine': hlexists('ALEErrorLine'),}
                            
                                    for l:item in l:item_list
                                        if l:item.type is# 'W'
                                            let l:group = 'ALEWarningLine'
                                        elseif l:item.type is# 'I'
                                            let l:group = 'ALEInfoLine'
                                        else
                                            let l:group = 'ALEErrorLine'
                                        endif
                            
                                        if l:available_groups[l:group]
                                            call s:highlight_line(l:item.bufnr, l:item.lnum, l:group)
                                        endif
                                    endfor
    7              0.000003     endif

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:213
Called 3 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
    3              0.000191   let p = resolve(expand('#'.a:bufnr.':p'))
    3              0.000132   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    3              0.000031   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    3              0.000006   endif
    3              0.000014   return g:gitgutter_diff_base

FUNCTION  ale#job#Start()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:221
Called 9 times
Total time:   0.010225
 Self time:   0.009747

count  total (s)   self (s)
    9   0.000091   0.000045     call ale#job#ValidateArguments(a:command, a:options)
                            
    9              0.000024     let l:job_info = copy(a:options)
    9              0.000012     let l:job_options = {}
                            
    9              0.000035     if has('nvim')
                                    if has_key(a:options, 'out_cb')
                                        let l:job_options.on_stdout = function('s:NeoVimCallback')
                                        let l:job_info.out_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'err_cb')
                                        let l:job_options.on_stderr = function('s:NeoVimCallback')
                                        let l:job_info.err_cb_line = ''
                                    endif
                            
                                    if has_key(a:options, 'exit_cb')
                                        let l:job_options.on_exit = function('s:NeoVimCallback')
                                    endif
                            
                                    let l:job_info.job = jobstart(a:command, l:job_options)
                                    let l:job_id = l:job_info.job
    9              0.000003     else
    9              0.000032         let l:job_options = {   'in_mode': l:job_info.mode,   'out_mode': l:job_info.mode,   'err_mode': l:job_info.mode,}
                            
    9              0.000016         if has_key(a:options, 'out_cb')
    9              0.000034             let l:job_options.out_cb = function('s:VimOutputCallback')
    9              0.000007         endif
                            
    9              0.000014         if has_key(a:options, 'err_cb')
                                        let l:job_options.err_cb = function('s:VimErrorCallback')
    9              0.000005         endif
                            
    9              0.000012         if has_key(a:options, 'exit_cb')
                                        " Set a close callback to which simply calls job_status()
                                        " when the channel is closed, which can trigger the exit callback
                                        " earlier on.
    9              0.000023             let l:job_options.close_cb = function('s:VimCloseCallback')
    9              0.000023             let l:job_options.exit_cb = function('s:VimExitCallback')
    9              0.000003         endif
                            
                                    " Use non-blocking writes for Vim versions that support the option.
    9              0.000025         if has('patch-8.1.350')
    9              0.000012             let l:job_options.noblock = 1
    9              0.000002         endif
                            
                                    " Vim 8 will read the stdin from the file's buffer.
    9              0.008538         let l:job_info.job = job_start(a:command, l:job_options)
    9   0.000877   0.000445         let l:job_id = ale#job#ParseVim8ProcessID(string(l:job_info.job))
    9              0.000009     endif
                            
    9              0.000012     if l:job_id > 0
                                    " Store the job in the map for later only if we can get the ID.
    9              0.000063         let s:job_map[l:job_id] = l:job_info
    9              0.000004     endif
                            
    9              0.000020     return l:job_id

FUNCTION  <SNR>90_PriorityCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:154
Called 3636 times
Total time:   0.009167
 Self time:   0.009167

count  total (s)   self (s)
 3636              0.003409     if s:supports_sign_groups
 3636              0.004984         return ' priority=' . g:ale_sign_priority . ' '
                                else
                                    return ''
                                endif

FUNCTION  ale#lsp_linter#StartLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:425
Called 3 times
Total time:   0.001192
 Self time:   0.000140

count  total (s)   self (s)
    3              0.000005     let l:command = ''
    3              0.000003     let l:address = ''
    3   0.000681   0.000031     let l:root = ale#lsp_linter#FindProjectRoot(a:buffer, a:linter)
                            
    3              0.000006     if empty(l:root) && a:linter.lsp isnot# 'tsserver'
                                    " If there's no project root, then we can't check files with LSP,
                                    " unless we are using tsserver, which doesn't use project roots.
                                    return 0
    3              0.000001     endif
                            
    3              0.000016     let l:options = {   'buffer': a:buffer,   'linter': a:linter,   'callback': a:Callback,   'root': l:root,}
                            
    3              0.000006     if a:linter.lsp is# 'socket'
                                    let l:address = ale#linter#GetAddress(a:buffer, a:linter)
                            
                                    return s:StartWithAddress(l:options, l:address)
    3              0.000003     endif
                            
    3   0.000117   0.000018     let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
    3   0.000320   0.000017     return s:StartIfExecutable(l:options, l:executable)

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:21
Called 6 times
Total time:   0.168943
 Self time:   0.001674

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
    6   0.000342   0.000108   if gitgutter#utility#getbufvar(a:bufnr, 'enabled', -1) == -1
                                call gitgutter#utility#setbufvar(a:bufnr, 'enabled', g:gitgutter_enabled)
    6              0.000012   endif
                            
    6   0.002995   0.000119   if gitgutter#utility#is_active(a:bufnr)
                            
    6              0.000079     if has('patch-7.4.1559')
    6              0.000088       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
    6              0.000010     endif
    6   0.031864   0.000139     let how = s:setup_path(a:bufnr, l:Callback)
    6              0.000038     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
    6              0.000009     endif
                            
    6              0.000035     if a:force || s:has_fresh_changes(a:bufnr)
                            
    6              0.000018       let diff = 'NOT SET'
    6              0.000012       try
    6   0.119030   0.000224         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
    3              0.000082       catch /gitgutter not tracked/
    3   0.001095   0.000087         call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter assume unchanged/
                                    call gitgutter#debug#log('Assume unchanged: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    6              0.000014       endtry
                            
    6              0.000040       if diff != 'async' && diff != 'NOT SET'
    3   0.012733   0.000113         call gitgutter#diff#handler(a:bufnr, diff)
    6              0.000009       endif
                            
    6              0.000008     endif
    6              0.000005   endif

FUNCTION  <SNR>90_BuildSignMap()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:307
Called 7 times
Total time:   1.532821
 Self time:   0.763258

count  total (s)   self (s)
    7   0.000114   0.000030     let l:max_signs = ale#Var(a:buffer, 'max_signs')
                            
    7              0.000011     if l:max_signs is 0
                                    let l:selected_grouped_items = []
    7              0.000023     elseif type(l:max_signs) is v:t_number && l:max_signs > 0
                                    let l:selected_grouped_items = a:grouped_items[:l:max_signs - 1]
    7              0.000004     else
    7              0.000010         let l:selected_grouped_items = a:grouped_items
    7              0.000003     endif
                            
    7              0.000008     let l:sign_map = {}
    7              0.000010     let l:sign_offset = g:ale_sign_offset
                            
20487              0.021451     for [l:line, l:sign_id, l:name] in a:current_sign_list
20480              0.091131         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
                                    " Increment the sign offset for new signs, by the maximum sign ID.
20480              0.022943         if l:sign_id > l:sign_offset
 3927              0.004381             let l:sign_offset = l:sign_id
20480              0.008022         endif
                            
                                    " Remember the sign names and IDs in separate Lists, so they are easy
                                    " to work with.
20480              0.030605         call add(l:sign_info.current_id_list, l:sign_id)
20480              0.030978         call add(l:sign_info.current_name_list, l:name)
                            
20480              0.040822         let l:sign_map[l:line] = l:sign_info
20487              0.008836     endfor
                            
20487              0.014121     for l:group in l:selected_grouped_items
20480              0.028549         let l:line = l:group[0].lnum
20480              0.093479         let l:sign_info = get(l:sign_map, l:line, {   'current_id_list': [],   'current_name_list': [],   'new_id': 0,   'new_name': '',   'items': [],})
                            
20480   0.849080   0.079601         let l:sign_info.new_name = ale#sign#GetSignName(l:group)
20480              0.025202         let l:sign_info.items = l:group
                            
20480              0.042498         let l:index = index(   l:sign_info.current_name_list,   l:sign_info.new_name)
                            
20480              0.018473         if l:index >= 0
                                        " We have a sign with this name already, so use the same ID.
16851              0.030667             let l:sign_info.new_id = l:sign_info.current_id_list[l:index]
 3629              0.001590         else
                                        " This sign name replaces the previous name, so use a new ID.
 3629              0.004885             let l:sign_info.new_id = l:sign_offset + 1
 3629              0.004284             let l:sign_offset += 1
20480              0.008440         endif
                            
20480              0.033462         let l:sign_map[l:line] = l:sign_info
20487              0.009139     endfor
                            
    7              0.000007     return l:sign_map

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:101
Called 6 times
Total time:   0.000512
 Self time:   0.000175

count  total (s)   self (s)
    6   0.000504   0.000167   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  ale#history#RememberOutput()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:58
Called 7 times
Total time:   0.000365
 Self time:   0.000075

count  total (s)   self (s)
    7   0.000348   0.000058     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
    7              0.000012     let l:obj.output = a:output

FUNCTION  ale#Var()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:180
Called 119 times
Total time:   0.001686
 Self time:   0.001686

count  total (s)   self (s)
  119              0.000368     let l:full_name = 'ale_' . a:variable_name
  119              0.000681     let l:vars = getbufvar(str2nr(a:buffer), '', {})
                            
  119              0.000509     return get(l:vars, l:full_name, g:[l:full_name])

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:72
Called 24 times
Total time:   0.001016
 Self time:   0.000948

count  total (s)   self (s)
   24              0.000694   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   21              0.000065     return a:arg
    3   0.000119   0.000051   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    3              0.000005   else
    3              0.000026     return shellescape(a:arg)
                              endif

FUNCTION  ale#ShouldDoNothing()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:32
Called 19 times
Total time:   0.002267
 Self time:   0.001649

count  total (s)   self (s)
                                " The checks are split into separate if statements to make it possible to
                                " profile each check individually with Vim's profiling tools.
                                "
                                " Do nothing if ALE is disabled.
   19              0.000113     if !getbufvar(a:buffer, 'ale_enabled', get(g:, 'ale_enabled', 0))
                                    return 1
   19              0.000010     endif
                            
                                " Don't perform any checks when newer NeoVim versions are exiting.
   19              0.000066     if get(v:, 'exiting', v:null) isnot v:null
                                    return 1
   19              0.000011     endif
                            
   19              0.000080     let l:filetype = getbufvar(a:buffer, '&filetype')
                            
                                " Do nothing when there's no filetype.
   19              0.000029     if l:filetype is# ''
                                    return 1
   19              0.000008     endif
                            
                                " Do nothing for diff buffers.
   19              0.000052     if getbufvar(a:buffer, '&diff')
                                    return 1
   19              0.000007     endif
                            
                                " Do nothing for blacklisted files.
   19              0.000104     if index(get(g:, 'ale_filetype_blacklist', []), l:filetype) >= 0
                                    return 1
   19              0.000006     endif
                            
                                " Do nothing if running from command mode.
   19              0.000078     if s:getcmdwintype_exists && !empty(getcmdwintype())
                                    return 1
   19              0.000010     endif
                            
   19              0.000092     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
                                " Do nothing for directories.
   19              0.000026     if l:filename is# '.'
                                    return 1
   19              0.000012     endif
                            
                                " Don't start linting and so on when an operator is pending.
   19   0.000198   0.000101     if ale#util#Mode(1) is# 'no'
                                    return 1
   19              0.000011     endif
                            
                                " Do nothing if running in the sandbox.
   19   0.000407   0.000088     if ale#util#InSandbox()
                                    return 1
   19              0.000013     endif
                            
                                " Do nothing if the file is too large.
   19   0.000295   0.000093     if ale#FileTooLarge(a:buffer)
                                    return 1
   19              0.000011     endif
                            
                                " Do nothing from CtrlP buffers with CtrlP-funky.
   19              0.000161     if exists(':CtrlPFunky') is 2&& getbufvar(a:buffer, '&l:statusline') =~# 'CtrlPMode.*funky'
                                    return 1
   19              0.000008     endif
                            
   19              0.000017     return 0

FUNCTION  <SNR>95_write_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:379
Called 3 times
Total time:   0.066055
 Self time:   0.066055

count  total (s)   self (s)
    3              0.000328   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    3              0.000024   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    3              0.000003   endif
                            
    3              0.000030   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    3              0.000005   endif
                            
    3              0.000020   if getbufvar(a:bufnr, '&endofline')
    3              0.000024     call add(bufcontents, '')
    3              0.000004   endif
                            
    3              0.000019   let fenc = getbufvar(a:bufnr, '&fileencoding')
    3              0.000013   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    3              0.000004   endif
                            
    3              0.000018   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]=''.bufcontents[0]
    3              0.000003   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    3              0.000007   try
    3              0.065273     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    3              0.000009   endtry

FUNCTION  <SNR>34_not_git_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:58
Called 6 times
Total time:   0.001268
 Self time:   0.000240

count  total (s)   self (s)
    6   0.001254   0.000226   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  ale#path#FindExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:102
Called 12 times
Total time:   0.005031
 Self time:   0.000283

count  total (s)   self (s)
   12   0.000231   0.000061     if ale#Var(a:buffer, a:base_var_name . '_use_global')
                                    return ale#Var(a:buffer, a:base_var_name . '_executable')
   12              0.000004     endif
                            
   12   0.004527   0.000074     let l:nearest = ale#path#FindNearestExecutable(a:buffer, a:path_list)
                            
   12              0.000023     if !empty(l:nearest)
                                    return l:nearest
   12              0.000004     endif
                            
   12   0.000192   0.000067     return ale#Var(a:buffer, a:base_var_name . '_executable')

FUNCTION  ale#handlers#textlint#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/textlint.vim:8
Called 3 times
Total time:   0.001233
 Self time:   0.000026

count  total (s)   self (s)
    3   0.001228   0.000021     return ale#path#FindExecutable(a:buffer, 'textlint', [   'node_modules/.bin/textlint',   'node_modules/textlint/bin/textlint.js',])

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:28
Called 3 times
Total time:   0.000496
 Self time:   0.000142

count  total (s)   self (s)
    3   0.000248   0.000052   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000019   let summary[0] += a:count
    3   0.000221   0.000063   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:181
Called 6 times
Total time:   0.002660
 Self time:   0.000406

count  total (s)   self (s)
    6   0.001412   0.000234   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    6   0.001234   0.000158   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  <SNR>80_VimOutputCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:68
Called 14440 times
Total time:   0.369883
 Self time:   0.232012

count  total (s)   self (s)
14440              0.023211     let l:job = ch_getjob(a:channel)
14440   0.112223   0.065250     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
                            
                                " Only call the callbacks for jobs which are valid.
14440              0.031419     if l:job_id > 0 && has_key(s:job_map, l:job_id)
14440   0.185176   0.094278         call ale#util#GetFunction(s:job_map[l:job_id].out_cb)(l:job_id, a:data)
14440              0.006308     endif

FUNCTION  <SNR>78_FindHistoryItem()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:36
Called 14 times
Total time:   0.000600
 Self time:   0.000493

count  total (s)   self (s)
                                " Search backwards to find a matching job ID. IDs might be recycled,
                                " so finding the last one should be good enough.
  108   0.000254   0.000147     for l:obj in reverse(ale#history#Get(a:buffer))
  108              0.000154         if l:obj.job_id == a:job_id
   14              0.000011             return l:obj
   94              0.000032         endif
   94              0.000043     endfor
                            
                                return {}

FUNCTION  ale#path#FindNearestFile()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:37
Called 27 times
Total time:   0.004014
 Self time:   0.004014

count  total (s)   self (s)
   27              0.000327     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
   27              0.000324     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
   27              0.003203     let l:relative_path = findfile(a:filename, l:buffer_filename . ';')
                            
   27              0.000052     if !empty(l:relative_path)
                                    return fnamemodify(l:relative_path, ':p')
   27              0.000013     endif
                            
   27              0.000019     return ''

FUNCTION  ale#history#SetExitCode()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:49
Called 7 times
Total time:   0.000385
 Self time:   0.000075

count  total (s)   self (s)
    7   0.000356   0.000046     let l:obj = s:FindHistoryItem(a:buffer, a:job_id)
                            
                                " If we find a match, then set the code and status.
    7              0.000010     let l:obj.exit_code = a:exit_code
    7              0.000008     let l:obj.status = 'finished'

FUNCTION  <SNR>95_is_removed()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:281
Called 6 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    6              0.000039   return a:from_count > 0 && a:to_count == 0

FUNCTION  ale#util#Writefile()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:432
Called 9 times
Total time:   0.060650
 Self time:   0.060650

count  total (s)   self (s)
    9              0.000065     let l:corrected_lines = getbufvar(a:buffer, '&fileformat') is# 'dos'   ? map(copy(a:lines), 'substitute(v:val, ''\r*$'', ''\r'', '''')')   : a:lines
                            
                                " Set binary flag if buffer doesn't have eol and nofixeol to avoid appending newline
    9              0.000124     let l:flags = !getbufvar(a:buffer, '&eol') && exists('+fixeol') && !&fixeol ? 'bS' : 'S'
                            
    9              0.060438     call writefile(l:corrected_lines, a:filename, l:flags) " no-custom-checks

FUNCTION  gitgutter#utility#set_repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:144
Called 3 times
Total time:   0.030970
 Self time:   0.000583

count  total (s)   self (s)
                              " Values of path:
                              " * non-empty string - path
                              " *               -1 - pending
                              " *               -2 - not tracked by git
                              " *               -3 - assume unchanged
                            
    3   0.000222   0.000062   call gitgutter#utility#setbufvar(a:bufnr, 'path', -1)
    3   0.001863   0.000169   let cmd = gitgutter#utility#cd_cmd(a:bufnr, g:gitgutter_git_executable.' '.g:gitgutter_git_args. ' ls-files -v --error-unmatch --full-name -z -- '. gitgutter#utility#shellescape(s:filename(a:bufnr)))
                            
    3   0.000100   0.000070   if g:gitgutter_async && gitgutter#async#available() && !has('vim_starting')
                                let handler = copy(s:set_path_handler)
                                let handler.continuation = a:continuation
                                call gitgutter#async#execute(cmd, a:bufnr, handler)
                                return 'async'
    3              0.000009   endif
                            
    3   0.028411   0.000076   let listing = gitgutter#utility#system(cmd)
                            
    3              0.000009   if v:shell_error
    3   0.000235   0.000067     call gitgutter#utility#setbufvar(a:bufnr, 'path', -2)
    3              0.000005     return
                              endif
                            
                              let listing = s:strip_trailing_new_line(listing)
                              let [status, path] = [listing[0], listing[2:]]
                              if status =~# '[a-z]'
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', -3)
                              else
                                call gitgutter#utility#setbufvar(a:bufnr, 'path', path)
                              endif

FUNCTION  <SNR>87_ShouldUseSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1082
Called 3 times
Total time:   0.003409
 Self time:   0.003409

count  total (s)   self (s)
    3              0.003406   return py3eval( 'vimsupport.VimSupportsPopupWindows()' )

FUNCTION  <SNR>74_RunJob()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:407
Called 9 times
Total time:   0.109942
 Self time:   0.002878

count  total (s)   self (s)
    9   0.000066   0.000033     if ale#command#IsDeferred(a:command)
                                    let a:command.result_callback = {   command -> s:RunJob(command, a:options)}
                            
                                    return 1
    9              0.000005     endif
                            
    9              0.000011     let l:command = a:command
                            
    9              0.000014     if empty(l:command)
                                    return 0
    9              0.000003     endif
                            
    9              0.000012     let l:cwd = a:options.cwd
    9              0.000016     let l:executable = a:options.executable
    9              0.000009     let l:buffer = a:options.buffer
    9              0.000013     let l:linter = a:options.linter
    9              0.000013     let l:output_stream = a:options.output_stream
    9              0.000018     let l:read_buffer = a:options.read_buffer && !a:options.lint_file
    9              0.000024     let l:info = g:ale_buffer_info[l:buffer]
                            
    9              0.000076     let l:Callback = function('s:HandleExit', [{   'linter': l:linter,   'executable': l:executable,}])
    9   0.106862   0.000248     let l:result = ale#command#Run(l:buffer, l:command, l:Callback, {   'cwd': l:cwd,   'output_stream': l:output_stream,   'executable': l:executable,   'read_buffer': l:read_buffer,   'log_output': 1,   'filename_mappings': ale#GetFilenameMappings(l:buffer, l:linter.name),})
                            
                                " Only proceed if the job is being run.
    9              0.000035     if empty(l:result)
                                    return 0
    9              0.000004     endif
                            
    9   0.002353   0.002090     call ale#engine#MarkLinterActive(l:info, l:linter)
                            
    9   0.000253   0.000099     silent doautocmd <nomodeline> User ALEJobStarted
                            
    9              0.000024     return 1

FUNCTION  <SNR>95_process_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:314
Called 3 times
Total time:   0.000246
 Self time:   0.000246

count  total (s)   self (s)
    3              0.000015   let offset = 0
    6              0.000054   while offset < a:to_count
    3              0.000018     let line_number = a:to_line + offset
    3              0.000056     call add(a:modifications, [line_number, 'modified'])
    3              0.000017     let offset += 1
    6              0.000020   endwhile

FUNCTION  <SNR>74_GetLintFileSlots()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:597
Called 3 times
Total time:   0.000553
 Self time:   0.000553

count  total (s)   self (s)
    3              0.000007     let l:linter_slots = []
                            
   33              0.000048     for l:linter in a:linters
   30              0.000076         let l:LintFile = l:linter.lint_file
                            
   30              0.000092         if type(l:LintFile) is v:t_func
                                        let l:LintFile = l:LintFile(a:buffer)
   30              0.000028         endif
                            
   30              0.000122         call add(l:linter_slots, [l:LintFile, l:linter])
   33              0.000031     endfor
                            
    3              0.000005     return l:linter_slots

FUNCTION  ale#cursor#EchoCursorWarning()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:72
Called 10 times
Total time:   0.005693
 Self time:   0.000479

count  total (s)   self (s)
   10              0.000029     let l:buffer = bufnr('')
                            
   10              0.000017     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
   10              0.000004     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
   10              0.000036     if mode(1) isnot# 'n'
    1              0.000001         return
    9              0.000003     endif
                            
    9   0.000926   0.000072     if ale#ShouldDoNothing(l:buffer)
                                    return
    9              0.000004     endif
                            
    9   0.004416   0.000056     let [l:info, l:loc] = ale#util#FindItemAtCursor(l:buffer)
                            
    9              0.000009     if g:ale_echo_cursor
    9              0.000013         if !empty(l:loc)
                                        let l:format = ale#Var(l:buffer, 'echo_msg_format')
                                        let l:msg = ale#GetLocItemMessage(l:loc, l:format)
                                        call ale#cursor#TruncatedEcho(l:msg)
                                        let l:info.echoed = 1
    9              0.000015         elseif get(l:info, 'echoed')
                                        " We'll only clear the echoed message when moving off errors once,
                                        " so we don't continually clear the echo line.
                                        "
                                        " no-custom-checks
                                        echo
                                        let l:info.echoed = 0
    9              0.000005         endif
    9              0.000003     endif
                            
    9              0.000011     if g:ale_cursor_detail
                                    if !empty(l:loc)
                                        call s:ShowCursorDetailForItem(l:loc, {'stay_here': 1})
                                    else
                                        call ale#preview#CloseIfTypeMatches('ale-preview')
                                    endif
    9              0.000003     endif

FUNCTION  ale#util#Mode()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:5
Called 19 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   19              0.000085     return call('mode', a:000)

FUNCTION  lightline#link()
    Defined: ~/.vim/bundle/lightline.vim/autoload/lightline.vim:218
Called 24 times
Total time:   0.006060
 Self time:   0.006060

count  total (s)   self (s)
   24              0.000377   let mode = get(s:lightline._mode_, a:0 ? a:1 : mode(), 'normal')
   24              0.000070   if s:mode ==# mode
   18              0.000031     return ''
    6              0.000007   endif
    6              0.000020   let s:mode = mode
    6              0.000028   if !has_key(s:highlight, mode)
                                call lightline#highlight(mode)
    6              0.000003   endif
    6              0.000137   let types = map(s:uniq(sort(filter(values(s:lightline.component_type), 'v:val !=# "raw"'))), '[v:val, 1]')
   18              0.000109   for [p, l] in [['Left', len(s:lightline.active.left)], ['Right', len(s:lightline.active.right)]]
   66              0.000197     for [i, t] in map(range(0, l), '[v:val, 0]') + types
   54              0.000093       if i != l
   42              0.000526         exec printf('hi link Lightline%s_active_%s Lightline%s_%s_%s', p, i, p, mode, i)
   54              0.000049       endif
  300              0.000739       for [j, s] in map(range(0, l), '[v:val, 0]') + types
  246              0.000523         if i + 1 == j || t || s && i != l
  114              0.001323           exec printf('hi link Lightline%s_active_%s_%s Lightline%s_%s_%s_%s', p, i, j, p, mode, i, j)
  246              0.000200         endif
  300              0.000256       endfor
   66              0.000076     endfor
   18              0.000016   endfor
    6              0.000045   exec printf('hi link LightlineMiddle_active LightlineMiddle_%s', mode)
    6              0.000006   return ''

FUNCTION  <SNR>34_use_known_shell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:194
Called 6 times
Total time:   0.000640
 Self time:   0.000640

count  total (s)   self (s)
    6              0.000087   if has('unix') && &shell !=# 'sh'
    6              0.000168     let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
    6              0.000095     let &shell = 'sh'
    6              0.000111     set shellcmdflag=-c shellredir=>%s\ 2>&1
    6              0.000011   endif
    6              0.000047   if has('win32') && (&shell =~# 'pwsh' || &shell =~# 'powershell')
                                let [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote] = [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote]
                                let &shell = 'cmd.exe'
                                set shellcmdflag=/s\ /c shellredir=>%s\ 2>&1 shellpipe=>%s\ 2>&1 shellquote= shellxquote="
    6              0.000009   endif

FUNCTION  <lambda>201()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   0.000024
 Self time:   0.000014

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>205()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   0.000024
 Self time:   0.000014

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#GetLocItemMessage()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:239
Called 32620 times
Total time:   1.097129
 Self time:   1.097129

count  total (s)   self (s)
32620              0.039501     let l:msg = a:format_string
32620              0.039940     let l:severity = g:ale_echo_msg_warning_str
32620              0.062497     let l:code = get(a:item, 'code', '')
32620              0.056435     let l:type = get(a:item, 'type', 'E')
32620              0.064105     let l:linter_name = get(a:item, 'linter_name', '')
32620              0.065646     let l:code_repl = !empty(l:code) ? '\=submatch(1) . l:code . submatch(2)' : ''
                            
32620              0.031049     if l:type is# 'E'
                                    let l:severity = g:ale_echo_msg_error_str
32620              0.029517     elseif l:type is# 'I'
                                    let l:severity = g:ale_echo_msg_info_str
32620              0.014233     endif
                            
                                " Replace special markers with certain information.
                                " \=l:variable is used to avoid escaping issues.
32620              0.166029     let l:msg = substitute(l:msg, '\v\%([^\%]*)code([^\%]*)\%', l:code_repl, 'g')
32620              0.093750     let l:msg = substitute(l:msg, '\V%severity%', '\=l:severity', 'g')
32620              0.086464     let l:msg = substitute(l:msg, '\V%linter%', '\=l:linter_name', 'g')
                                " Replace %s with the text.
32620              0.100385     let l:msg = substitute(l:msg, '\V%s', '\=a:item.text', 'g')
                                " Windows may insert carriage return line endings (^M), strip these characters.
32620              0.079072     let l:msg = substitute(l:msg, '\r', '', 'g')
                            
32620              0.025840     return l:msg

FUNCTION  <SNR>95_save_last_seen_change()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:419
Called 3 times
Total time:   0.000255
 Self time:   0.000074

count  total (s)   self (s)
    3   0.000247   0.000066   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  ale#sign#SetSigns()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:442
Called 7 times
Total time:   3.950963
 Self time:   0.085812

count  total (s)   self (s)
    7              0.000021     if !bufexists(str2nr(a:buffer))
                                    " Stop immediately when attempting to set signs for a buffer which
                                    " does not exist.
                                    return
    7              0.000004     endif
                            
                                " Find the current markers
    7   0.175353   0.000053     let [l:is_dummy_sign_set, l:current_sign_list] =   ale#sign#FindCurrentSigns(a:buffer)
                            
                                " Update the line numbers for items from before which may have moved.
    7   1.223946   0.002982     call s:UpdateLineNumbers(a:buffer, l:current_sign_list, a:loclist)
                            
                                " Group items after updating the line numbers.
    7   0.300220   0.000167     let l:grouped_items = s:GroupLoclistItems(a:buffer, a:loclist)
                            
                                " Build a map of current and new signs, with the lines as the keys.
    7   1.532957   0.000136     let l:sign_map = s:BuildSignMap(   a:buffer,   l:current_sign_list,   l:grouped_items,)
                            
    7   0.636071   0.000058     let l:command_list = ale#sign#GetSignCommands(   a:buffer,   l:is_dummy_sign_set,   l:sign_map,)
                            
                                " Change the sign column color if the option is on.
    7              0.000015     if g:ale_change_sign_column_color && !empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithErrors
    7              0.000005     endif
                            
 7279              0.005039     for l:command in l:command_list
 7272              0.073464         silent! execute l:command
 7279              0.003039     endfor
                            
                                " Reset the sign column color when there are no more errors.
    7              0.000015     if g:ale_change_sign_column_color && empty(a:loclist)
                                    highlight clear SignColumn
                                    highlight link SignColumn ALESignColumnWithoutErrors
    7              0.000003     endif

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:235
Called 3 times
Total time:   0.005989
 Self time:   0.000394

count  total (s)   self (s)
    3              0.000017   let modified_lines = []
   12              0.000048   for hunk in a:hunks
    9   0.005834   0.000239     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
   12              0.000034   endfor
    3              0.000010   return modified_lines

FUNCTION  ale#job#Stop()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:352
Called 2 times
Total time:   0.000115
 Self time:   0.000084

count  total (s)   self (s)
    2              0.000006     if !has_key(s:job_map, a:job_id)
                                    return
    2              0.000001     endif
                            
    2              0.000009     if has('nvim')
                                    " FIXME: NeoVim kills jobs on a timer, but will not kill any processes
                                    " which are child processes on Unix. Some work needs to be done to
                                    " kill child processes to stop long-running processes like pylint.
                                    silent! call jobstop(a:job_id)
    2              0.000001     else
    2              0.000006         let l:job = s:job_map[a:job_id].job
                            
                                    " We must close the channel for reading the buffer if it is open
                                    " when stopping a job. Otherwise, we will get errors in the status line.
    2              0.000007         if ch_status(job_getchannel(l:job)) is# 'open'
    2              0.000011             call ch_close_in(job_getchannel(l:job))
    2              0.000000         endif
                            
                                    " Ask nicely for the job to stop.
    2              0.000012         call job_stop(l:job)
                            
    2   0.000042   0.000011         if ale#job#IsRunning(l:job)
                                        " Set a 100ms delay for killing the job with SIGKILL.
                                        let s:job_kill_timers[timer_start(100, function('s:KillHandler'))] = l:job
    2              0.000000         endif
    2              0.000002     endif

FUNCTION  vimtex#pos#set_cursor()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/pos.vim:7
Called 9 times
Total time:   0.000539
 Self time:   0.000123

count  total (s)   self (s)
    9   0.000535   0.000119   call cursor(s:parse_args(a:000))

FUNCTION  ale#engine#InitBufferInfo()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:82
Called 3 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    3              0.000013     if !has_key(g:ale_buffer_info, a:buffer)
                                    " active_linter_list will hold the list of active linter names
                                    " loclist holds the loclist items after all jobs have completed.
                                    let g:ale_buffer_info[a:buffer] = {   'active_linter_list': [],   'active_other_sources_list': [],   'loclist': [],}
                            
                                    return 1
    3              0.000003     endif
                            
    3              0.000004     return 0

FUNCTION  ale#FileTooLarge()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:24
Called 19 times
Total time:   0.000202
 Self time:   0.000202

count  total (s)   self (s)
   19              0.000103     let l:max = getbufvar(a:buffer, 'ale_maximum_file_size', get(g:, 'ale_maximum_file_size', 0))
                            
   19              0.000080     return l:max > 0 ? (line2byte(line('$') + 1) > l:max) : 0

FUNCTION  ale#engine#MarkLinterInactive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:43
Called 7 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    7              0.000050     call filter(a:info.active_linter_list, 'v:val.name isnot# a:linter_name')

FUNCTION  <SNR>95_is_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:277
Called 9 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    9              0.000058   return a:from_count == 0 && a:to_count > 0

FUNCTION  ale#engine#IsCheckingBuffer()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:101
Called 17 times
Total time:   0.000184
 Self time:   0.000184

count  total (s)   self (s)
   17              0.000077     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   17              0.000088     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  ale#job#ValidateArguments()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:144
Called 9 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    9              0.000020     if a:options.mode isnot# 'nl' && a:options.mode isnot# 'raw'
                                    throw 'Invalid mode: ' . a:options.mode
    9              0.000005     endif

FUNCTION  ale#engine#MarkLinterActive()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:28
Called 9 times
Total time:   0.000263
 Self time:   0.000263

count  total (s)   self (s)
    9              0.000048     let l:found = 0
                            
   18              0.000046     for l:other_linter in a:info.active_linter_list
    9              0.000029         if l:other_linter.name is# a:linter.name
                                        let l:found = 1
                                        break
    9              0.000003         endif
   18              0.000015     endfor
                            
    9              0.000008     if !l:found
    9              0.000031         call add(a:info.active_linter_list, a:linter)
    9              0.000003     endif

FUNCTION  ale#command#ResetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:39
Called 7 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    7              0.000014     if has_key(s:buffer_data, a:buffer)
    7              0.000015         let s:buffer_data[a:buffer].cwd = v:null
    7              0.000003     endif

FUNCTION  ale_linters#tex#lacheck#Handle()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/lacheck.vim:6
Called 3 times
Total time:   0.107300
 Self time:   0.054006

count  total (s)   self (s)
                                " Mattes lines like:
                                "
                                " "book.tex", line 37: possible unwanted space at "{"
                                " "book.tex", line 38: missing `\ ' after "etc."
    3              0.000006     let l:pattern = '^"\(.\+\)", line \(\d\+\): \(.\+\)$'
    3              0.000003     let l:output = []
                            
 2868   0.057114   0.003820     for l:match in ale#util#GetMatches(a:lines, l:pattern)
                                    " lacheck follows `\input{}` commands. If the cwd is not the same as the
                                    " file in the buffer then it will fail to find the inputed items. We do not
                                    " want warnings from those items anyway
 2865              0.010949         if !empty(matchstr(l:match[3], '^Could not open ".\+"$'))
                                        continue
 2865              0.001016         endif
                            
                                    " lacheck follows `\input{}` commands. We are only interested in
                                    " reporting errors for the current buffer only.
 2865              0.016939         if empty(matchstr(fnamemodify(l:match[1], ':t'), fnamemodify(bufname(a:buffer), ':t')))
                                        continue
 2865              0.001068         endif
                            
 2865              0.010935         call add(l:output, {   'lnum': l:match[2] + 0,   'text': l:match[3],   'type': 'W',})
 2868              0.001261     endfor
                            
    3              0.000005     return l:output

FUNCTION  <SNR>87_OnFileReadyToParse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:740
Called 3 times
Total time:   0.005692
 Self time:   0.005507

count  total (s)   self (s)
                              " Accepts an optional parameter that is either 0 or 1. If 1, send a
                              " FileReadyToParse event notification, whether the buffer has changed or not;
                              " effectively forcing a parse of the buffer. Default is 0.
    3              0.000012   let force_parsing = a:0 > 0 && a:1
                            
                              " We only want to send a new FileReadyToParse event notification if the buffer
                              " has changed since the last time we sent one, or if forced.
    3              0.000313   if force_parsing || py3eval( "ycm_state.NeedsReparse()" )
                                " We switched buffers or somethuing, so claer.
                                " FIXME: sig hekp should be buffer local?
    2   0.000192   0.000020     call s:ClearSignatureHelp()
    2              0.005050     py3 ycm_state.OnFileReadyToParse()
                            
    2   0.000053   0.000040     call s:StopPoller( s:pollers.file_parse_response )
    2              0.000014     let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
    3              0.000004   endif

FUNCTION  ale#sign#ParseSignsWithGetPlaced()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:205
Called 7 times
Total time:   0.171757
 Self time:   0.171757

count  total (s)   self (s)
    7              0.011421     let l:signs = sign_getplaced(a:buffer, { 'group': s:supports_sign_groups ? 'ale' : '' })[0].signs
    7              0.000013     let l:result = []
    7              0.000007     let l:is_dummy_sign_set = 0
                            
20487              0.013065     for l:sign in l:signs
20480              0.025008         if l:sign['name'] is# 'ALEDummySign'
                                        let l:is_dummy_sign_set = 1
20480              0.008024         else
20480              0.081110             call add(l:result, [   str2nr(l:sign['lnum']),   str2nr(l:sign['id']),   l:sign['name'],])
20480              0.007827         endif
20487              0.008232     endfor
                            
    7              0.000014     return [l:is_dummy_sign_set, l:result]

FUNCTION  ale#command#FormatCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:192
Called 9 times
Total time:   0.081608
 Self time:   0.004635

count  total (s)   self (s)
    9              0.000012     let l:temporary_file = ''
    9              0.000012     let l:command = a:command
                            
    9              0.000023     if !empty(a:cwd)
                                    let l:command = ale#command#CdString(a:cwd) . l:command
    9              0.000006     endif
                            
                                " First replace all uses of %%, used for literal percent characters,
                                " with an ugly string.
    9              0.000047     let l:command = substitute(l:command, '%%', '<<PERCENTS>>', 'g')
                            
                                " Replace %e with the escaped executable, if available.
    9              0.000030     if !empty(a:executable) && l:command =~# '%e'
    3   0.000073   0.000030         let l:command = substitute(l:command, '%e', '\=ale#Escape(a:executable)', 'g')
    9              0.000003     endif
                            
                                " Replace all %s occurrences in the string with the name of the current
                                " file.
    9              0.000019     if l:command =~# '%s'
                                    let l:filename = fnamemodify(bufname(a:buffer), ':p')
                                    let l:command = substitute(   l:command,   s:path_format_regex,   '\=s:FormatFilename(l:filename, a:mappings, submatch(1))',   'g')
    9              0.000004     endif
                            
    9              0.000024     if a:input isnot v:false && l:command =~# '%t'
                                    " Create a temporary filename, <temp_dir>/<original_basename>
                                    " The file itself will not be created by this function.
    6   0.000301   0.000041         let l:temporary_file = s:TemporaryFilename(a:buffer)
    6   0.000307   0.000123         let l:command = substitute(   l:command,   '\v\%t(%(:h|:t|:r|:e)*)',   '\=s:FormatFilename(l:temporary_file, a:mappings, submatch(1))',   'g')
    9              0.000006     endif
                            
                                " Finish formatting so %% becomes %.
    9              0.000053     let l:command = substitute(l:command, '<<PERCENTS>>', '%', 'g')
                            
    9              0.000021     if a:pipe_file_if_needed && empty(l:temporary_file)
                                    " If we are to send the Vim buffer to a command, we'll do it
                                    " in the shell. We'll write out the file to a temporary file,
                                    " and then read it back in, in the shell.
    3   0.000126   0.000019         let l:temporary_file = s:TemporaryFilename(a:buffer)
    3   0.000053   0.000014         let l:command = l:command . ' < ' . ale#Escape(l:temporary_file)
    9              0.000004     endif
                            
    9   0.080243   0.003903     let l:file_created = ale#command#CreateTempFile(   a:buffer,   l:temporary_file,   a:input,)
                            
    9              0.000033     return [l:temporary_file, l:command, l:file_created]

FUNCTION  ale#command#Run()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:333
Called 9 times
Total time:   0.106343
 Self time:   0.006658

count  total (s)   self (s)
    9              0.000026     let l:options = get(a:000, 0, {})
                            
    9              0.000017     if len(a:000) > 1
                                    throw 'Too many arguments!'
    9              0.000001     endif
                            
    9              0.000025     let l:output_stream = get(l:options, 'output_stream', 'stdout')
    9              0.000010     let l:line_list = []
    9              0.000020     let l:cwd = get(l:options, 'cwd', v:null)
                            
    9              0.000010     if l:cwd is v:null
                                    " Default the working directory to whatever it was for the last
                                    " command run in the chain.
    9              0.000038         let l:cwd = get(get(s:buffer_data, a:buffer, {}), 'cwd', v:null)
    9              0.000003     endif
                            
    9   0.081756   0.000148     let [l:temporary_file, l:command, l:file_created] = ale#command#FormatCommand(   a:buffer,   get(l:options, 'executable', ''),   a:command,   get(l:options, 'read_buffer', 0),   get(l:options, 'input', v:null),   l:cwd,   get(l:options, 'filename_mappings', []),)
    9   0.005099   0.004481     let l:command = ale#job#PrepareCommand(a:buffer, l:command)
    9              0.000119     let l:job_options = {   'exit_cb': {job_id, exit_code -> s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )},   'mode': 'nl',}
                            
    9              0.000012     if l:output_stream is# 'stdout'
    9              0.000048         let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'stderr'
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
                                elseif l:output_stream is# 'both'
                                    let l:job_options.out_cb = function('s:GatherOutput', [l:line_list])
                                    let l:job_options.err_cb = function('s:GatherOutput', [l:line_list])
    9              0.000006     endif
                            
    9              0.000010     let l:status = 'failed'
                            
    9              0.000020     if get(g:, 'ale_run_synchronously') == 1
                                    if get(g:, 'ale_emulate_job_failure') == 1
                                        let l:job_id = 0
                                    else
                                        " Generate a fake job ID for tests.
                                        let s:fake_job_id = get(s:, 'fake_job_id', 0) + 1
                                        let l:job_id = s:fake_job_id
                                    endif
    9              0.000016     elseif has('win32')
                                    let l:job_id = ale#job#StartWithCmd(l:command, l:job_options)
    9              0.000004     else
    9   0.010602   0.000377         let l:job_id = ale#job#Start(l:command, l:job_options)
    9              0.000008     endif
                            
    9              0.000006     if l:job_id
    9              0.000040         let l:status = 'started'
    9              0.000057         let l:job_type = getbufvar(a:buffer, 'ale_job_type', 'all')
                            
    9   0.000265   0.000134         call ale#command#InitData(a:buffer)
    9              0.000053         let s:buffer_data[a:buffer].jobs[l:job_id] = l:job_type
    9              0.000002     endif
                            
    9              0.000009     if g:ale_history_enabled
    9   0.007232   0.000129         call ale#history#Add(a:buffer, l:status, l:job_id, l:command)
    9              0.000008     endif
                            
    9              0.000014     if !l:job_id
                                    return 0
    9              0.000002     endif
                            
                                " We'll return this Dictionary. A `result_callback` can be assigned to it
                                " later for capturing the result of a:Callback.
                                "
                                " The `_deferred_job_id` is used for both checking the type of object, and
                                " for checking the job ID and status.
                                "
                                " The cwd is kept and used as the default value for the next command in
                                " the chain.
                                "
                                " The original command here is used in tests.
    9              0.000078     let l:result = {   '_deferred_job_id': l:job_id,   'executable': get(l:options, 'executable', ''),   'cwd': l:cwd,   'command': a:command,}
                            
    9              0.000025     if get(g:, 'ale_run_synchronously') == 1 && l:job_id
                                    if !exists('g:ale_run_synchronously_callbacks')
                                        let g:ale_run_synchronously_callbacks = []
                                    endif
                            
                                    if get(g:, 'ale_run_synchronously_emulate_commands', 0)
                                        call add(   g:ale_run_synchronously_callbacks,   {exit_code, output -> [       extend(l:line_list, output),       l:job_options.exit_cb(l:job_id, exit_code),   ]})
                                    else
                                        " Run a command synchronously if this test option is set.
                                        call extend(l:line_list, systemlist(   type(l:command) is v:t_list       ? join(l:command[0:1]) . ' ' . ale#Escape(l:command[2])       : l:command))
                            
                                        " Don't capture output when the callbacks aren't set.
                                        if !has_key(l:job_options, 'out_cb')&& !has_key(l:job_options, 'err_cb')
                                            let l:line_list = []
                                        endif
                            
                                        call add(   g:ale_run_synchronously_callbacks,   {-> l:job_options.exit_cb(l:job_id, v:shell_error)})
                                    endif
    9              0.000006     endif
                            
    9              0.000028     return l:result

FUNCTION  ale#job#ParseVim8ProcessID()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:140
Called 14467 times
Total time:   0.047483
 Self time:   0.047483

count  total (s)   self (s)
14467              0.045035     return matchstr(a:job_string, '\d\+') + 0

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/debug.vim:70
Called 12 times
Total time:   0.001340
 Self time:   0.001340

count  total (s)   self (s)
   12              0.000050   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   12              0.000019   endif

FUNCTION  <SNR>95_process_modified_and_removed()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:337
Called 3 times
Total time:   0.000572
 Self time:   0.000572

count  total (s)   self (s)
    3              0.000011   let offset = 0
   18              0.000064   while offset < a:to_count
   15              0.000063     let line_number = a:to_line + offset
   15              0.000219     call add(a:modifications, [line_number, 'modified'])
   15              0.000065     let offset += 1
   18              0.000044   endwhile
    3              0.000035   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  <SNR>74_RunIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:533
Called 27 times
Total time:   0.113738
 Self time:   0.001355

count  total (s)   self (s)
   27   0.000238   0.000112     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:RunIfExecutable(       a:buffer,       a:linter,       a:lint_file,       executable   )}
                            
                                    return 1
   27              0.000008     endif
                            
   27   0.001685   0.000117     if ale#engine#IsExecutable(a:buffer, a:executable)
                                    " Use different job types for file or linter jobs.
    9              0.000017         let l:job_type = a:lint_file ? 'file_linter' : 'linter'
    9              0.000038         call setbufvar(a:buffer, 'ale_job_type', l:job_type)
                            
                                    " Get the cwd for the linter and set it before we call GetCommand.
                                    " This will ensure that ale#command#Run uses it by default.
    9   0.000125   0.000049         let l:cwd = ale#linter#GetCwd(a:buffer, a:linter)
                            
    9              0.000013         if l:cwd isnot v:null
                                        call ale#command#SetCwd(a:buffer, l:cwd)
    9              0.000002         endif
                            
    9   0.000713   0.000042         let l:command = ale#linter#GetCommand(a:buffer, a:linter)
                            
    9              0.000011         if l:cwd isnot v:null
                                        call ale#command#ResetCwd(a:buffer)
    9              0.000003         endif
                            
    9              0.000083         let l:options = {   'cwd': l:cwd,   'executable': a:executable,   'buffer': a:buffer,   'linter': a:linter,   'output_stream': get(a:linter, 'output_stream', 'stdout'),   'read_buffer': a:linter.read_buffer,   'lint_file': a:lint_file,}
                            
    9   0.110155   0.000213         return s:RunJob(l:command, l:options)
   18              0.000009     endif
                            
   18              0.000013     return 0

FUNCTION  ale#command#IsDeferred()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:471
Called 99 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
   99              0.000410     return type(a:value) is v:t_dict && has_key(a:value, '_deferred_job_id')

FUNCTION  ale#path#IsAbsolute()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:117
Called 24 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   24              0.000088     if has('win32') && a:filename[:0] is# '\'
                                    return 1
   24              0.000010     endif
                            
                                " Check for /foo and C:\foo, etc.
   24              0.000087     return a:filename[:0] is# '/' || a:filename[1:2] is# ':\'

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:87
Called 3 times
Total time:   0.000280
 Self time:   0.000046

count  total (s)   self (s)
    3   0.000276   0.000042   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  ale_linters#tex#chktex#GetCommand()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/chktex.vim:10
Called 3 times
Total time:   0.000588
 Self time:   0.000074

count  total (s)   self (s)
                                " Check for optional .chktexrc
    3   0.000479   0.000017     let l:chktex_config = ale#path#FindNearestFile(   a:buffer,   '.chktexrc')
                            
    3   0.000041   0.000014     let l:command = ale#Var(a:buffer, 'tex_chktex_executable')
                                " Avoid bug when used without -p (last warning has gibberish for a filename)
    3              0.000006     let l:command .= ' -v0 -p stdin -q'
                            
    3              0.000005     if !empty(l:chktex_config)
                                    let l:command .= ' -l ' . ale#Escape(l:chktex_config)
    3              0.000001     endif
                            
    3   0.000036   0.000011     let l:command .= ' ' . ale#Var(a:buffer, 'tex_chktex_options')
                            
    3              0.000003     return l:command

FUNCTION  <SNR>34_abs_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:222
Called 33 times
Total time:   0.004075
 Self time:   0.003926

count  total (s)   self (s)
   33              0.001962   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   33              0.001463   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   33   0.000428   0.000279   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:10
Called 3 times
Total time:   0.000191
 Self time:   0.000064

count  total (s)   self (s)
    3   0.000185   0.000058   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>54_ApplyPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:447
Called 7 times
Total time:   6.451648
 Self time:   0.000130

count  total (s)   self (s)
    7              0.000026     if has_key(s:partial_timers, a:timer_id)
    7              0.000036         let [l:Callback, l:args] = remove(s:partial_timers, a:timer_id)
    7   6.451578   0.000060         call call(l:Callback, [a:timer_id] + l:args)
    7              0.000003     endif

FUNCTION  191()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/matchparen.vim:66
Called 9 times
Total time:   0.000371
 Self time:   0.000371

count  total (s)   self (s)
    9              0.000209   silent! call matchdelete(w:vimtex_match_id1)
    9              0.000110   silent! call matchdelete(w:vimtex_match_id2)
    9              0.000025   unlet! w:vimtex_match_id1
    9              0.000012   unlet! w:vimtex_match_id2

FUNCTION  192()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/matchparen.vim:72
Called 9 times
Total time:   0.007694
 Self time:   0.000621

count  total (s)   self (s)
    9   0.000435   0.000064   call self.clear()
                            
    9   0.001633   0.000127   if vimtex#syntax#in_comment() | return | endif
                            
                              " This is a hack to ensure that $ in visual block mode adhers to the rule
                              " specified in :help v_$
    9              0.000054   if mode() ==# "\<c-v>"
                                let l:pos = vimtex#pos#get_cursor()
                                if len(l:pos) == 5 && l:pos[-1] == 2147483647
                                  call feedkeys('$', 'in')
                                endif
    9              0.000006   endif
                            
    9   0.005320   0.000124   let l:current = vimtex#delim#get_current('all', 'both')
    9              0.000059   if empty(l:current) | return | endif
                            
                              let l:corresponding = vimtex#delim#get_matching(l:current)
                              if empty(l:corresponding) | return | endif
                              if empty(l:corresponding.match) | return | endif
                            
                              let [l:open, l:close] = l:current.is_open ? [l:current, l:corresponding] : [l:corresponding, l:current]
                            
                              let w:vimtex_match_id1 = matchaddpos('MatchParen', [[l:open.lnum, l:open.cnum, strlen(l:open.match)]])
                              let w:vimtex_match_id2 = matchaddpos('MatchParen', [[l:close.lnum, l:close.cnum, strlen(l:close.match)]])

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:57
Called 3 times
Total time:   0.002159
 Self time:   0.001313

count  total (s)   self (s)
    3              0.000032   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    3              0.000110     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    3   0.000205   0.000072     let modified_lines = s:handle_double_hunk(a:modified_lines)
    3   0.001608   0.000895     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    3              0.000047     if exists('*sign_placelist')
    3              0.000108       call sign_placelist(signs)
    3              0.000008       return
                                endif
                            
                                for sign in signs
                                  call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
                                endfor
                                return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>74_RemoveProblemsForDisabledLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:483
Called 3 times
Total time:   0.053144
 Self time:   0.053144

count  total (s)   self (s)
                                " Figure out which linters are still enabled, and remove
                                " problems for linters which are no longer enabled.
                                " Problems from other sources will be kept.
    3              0.000008     let l:name_map = {}
                            
   33              0.000043     for l:linter in a:linters
   30              0.000103         let l:name_map[l:linter.name] = 1
   33              0.000028     endfor
                            
    3              0.052937     call filter(   get(g:ale_buffer_info[a:buffer], 'loclist', []),   'get(v:val, ''from_other_source'') || get(l:name_map, get(v:val, ''linter_name''))',)

FUNCTION  196()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:110
Called 1 time
Total time:   0.000177
 Self time:   0.000177

count  total (s)   self (s)
    1              0.000006   let self.finished = 0
    1              0.000004   let self.amp_ind = -1
    1              0.000004   let self.init_ind = -1
    1              0.000004   let self.prev_lnum = a:plnum
    1              0.000005   let self.prev_line = a:pline
    1              0.000011   let self.prev_ind = a:plnum > 0 ? indent(a:plnum) : 0
    1              0.000011   if !g:vimtex_indent_on_ampersands | return self.prev_ind | endif
                            
    1              0.000048   if a:cline =~# s:re_align || a:cline =~# s:re_amp || a:cline =~# '^\v\s*\\%(end|])'
                                call self.parse_context(a:lnum, a:cline)
    1              0.000002   endif
                            
    1              0.000012   if a:cline =~# s:re_align
                                let self.finished = 1
                                let l:ind_diff =   strdisplaywidth(strpart(a:cline, 0, match(a:cline, s:re_amp))) - strdisplaywidth(strpart(a:cline, 0, match(a:cline, '\S')))
                                return self.amp_ind - l:ind_diff
    1              0.000001   endif
                            
    1              0.000008   if self.amp_ind >= 0 && (a:cline =~# '^\v\s*\\%(end|])' || a:cline =~# s:re_amp)
                                let self.prev_lnum = self.init_lnum
                                let self.prev_line = self.init_line
                                return self.init_ind
    1              0.000002   endif
                            
    1              0.000003   return self.prev_ind

FUNCTION  ale#util#LocItemCompareWithText()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:209
Called 230394 times
Total time:   4.328720
 Self time:   1.321781

count  total (s)   self (s)
230394   3.873159   0.866220     let l:cmp_value = ale#util#LocItemCompare(a:left, a:right)
                            
230394              0.171721     if l:cmp_value
224709              0.166011         return l:cmp_value
 5685              0.002222     endif
                            
 5685              0.006628     if a:left.text < a:right.text
 2895              0.001775         return -1
 2790              0.001053     endif
                            
 2790              0.002864     if a:left.text > a:right.text
  903              0.000563         return 1
 1887              0.000674     endif
                            
 1887              0.001142     return 0

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:34
Called 6 times
Total time:   0.001101
 Self time:   0.000296

count  total (s)   self (s)
    6   0.000581   0.000111   let summary = gitgutter#hunk#summary(a:bufnr)
    6              0.000038   let summary[1] += a:count
    6   0.000472   0.000137   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  ale#Queue()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:123
Called 3 times
Total time:   0.077850
 Self time:   0.000369

count  total (s)   self (s)
    3              0.000013     if a:0 > 2
                                    throw 'too many arguments!'
    3              0.000006     endif
                            
    3              0.000023     let l:buffer = get(a:000, 1, v:null)
                            
    3              0.000015     if l:buffer is v:null
    3              0.000016         let l:buffer = bufnr('')
    3              0.000002     endif
                            
    3              0.000017     if type(l:buffer) isnot v:t_number
                                    throw 'buffer_number must be a Number'
    3              0.000003     endif
                            
    3   0.000747   0.000041     if ale#ShouldDoNothing(l:buffer)
                                    return
    3              0.000004     endif
                            
                                " Default linting_flag to ''
    3              0.000020     let l:should_lint_file = get(a:000, 0) is# 'lint_file'
                            
    3              0.000011     if s:lint_timer != -1
    2              0.000010         call timer_stop(s:lint_timer)
    2              0.000010         let s:lint_timer = -1
    3              0.000025     endif
                            
    3              0.000008     if a:delay > 0
    2              0.000029         let s:lint_timer = timer_start(   a:delay,   function('s:Lint', [l:buffer, l:should_lint_file]))
    1              0.000002     else
    1   0.076801   0.000026         call s:Lint(l:buffer, l:should_lint_file, 0)
    3              0.000004     endif

FUNCTION  VimtexIndentExpr()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:32
Called 1 time
Total time:   0.001999
 Self time:   0.000039

count  total (s)   self (s)
    1   0.001995   0.000035   return VimtexIndent(v:lnum)

FUNCTION  ale#engine#IsExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:53
Called 30 times
Total time:   0.001812
 Self time:   0.001030

count  total (s)   self (s)
   30              0.000059     if empty(a:executable)
                                    " Don't log the executable check if the executable string is empty.
                                    return 0
   30              0.000016     endif
                            
                                " Check for a cached executable() check.
   30              0.000108     let l:result = get(s:executable_cache_map, a:executable, v:null)
                            
   30              0.000042     if l:result isnot v:null
    9              0.000008         return l:result
   21              0.000007     endif
                            
                                " Check if the file is executable, and convert -1 to 1.
   21              0.000349     let l:result = executable(a:executable) isnot 0
                            
                                " Cache the executable check if we found it, or if the option to cache
                                " failing checks is on.
   21              0.000053     if l:result || get(g:, 'ale_cache_executable_check_failures', 0)
                                    let s:executable_cache_map[a:executable] = l:result
   21              0.000008     endif
                            
   21              0.000020     if g:ale_history_enabled
   21   0.000914   0.000132         call ale#history#Add(a:buffer, l:result, 'executable', a:executable)
   21              0.000011     endif
                            
   21              0.000020     return l:result

FUNCTION  vimtex#syntax#in()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/syntax.vim:18
Called 9 times
Total time:   0.001371
 Self time:   0.000199

count  total (s)   self (s)
    9   0.001363   0.000191   return match(call('vimtex#syntax#stack', a:000), '^' . a:name) >= 0

FUNCTION  <SNR>87_IdentifierFinishedOperations()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:931
Called 1 time
Total time:   0.002427
 Self time:   0.002427

count  total (s)   self (s)
    1              0.000036   if !py3eval( 'base.CurrentIdentifierFinished()' )
                                return
    1              0.000000   endif
    1              0.002382   py3 ycm_state.OnCurrentIdentifierFinished()
    1              0.000004   let s:force_semantic = 0
    1              0.000003   let s:completion = s:default_completion

FUNCTION  <SNR>74_GetLintFileValues()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:613
Called 3 times
Total time:   0.177467
 Self time:   0.001199

count  total (s)   self (s)
    3              0.000007     let l:deferred_list = []
    3              0.000006     let l:new_slots = []
                            
   33              0.000064     for [l:lint_file, l:linter] in a:slots
   30   0.000395   0.000253         while ale#command#IsDeferred(l:lint_file) && has_key(l:lint_file, 'value')
                                        " If we've already computed the return value, use it.
                                        let l:lint_file = l:lint_file.value
   30              0.000025         endwhile
                            
   30   0.000325   0.000192         if ale#command#IsDeferred(l:lint_file)
                                        " If we are going to return the result later, wait for it.
                                        call add(l:deferred_list, l:lint_file)
   30              0.000035         else
                                        " If we have the value now, coerce it to 0 or 1.
   30              0.000067             let l:lint_file = l:lint_file is 1
   30              0.000033         endif
                            
   30              0.000114         call add(l:new_slots, [l:lint_file, l:linter])
   33              0.000025     endfor
                            
    3              0.000008     if !empty(l:deferred_list)
                                    for l:deferred in l:deferred_list
                                        let l:deferred.result_callback =   {-> s:GetLintFileValues(l:new_slots, a:Callback)}
                                    endfor
    3              0.000002     else
    3   0.176026   0.000033         call a:Callback(l:new_slots)
    3              0.000002     endif

FUNCTION  ale#Escape()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:219
Called 12 times
Total time:   0.000174
 Self time:   0.000174

count  total (s)   self (s)
   12              0.000055     if fnamemodify(&shell, ':t') is? 'cmd.exe'
                                    " If the string contains spaces, it will be surrounded by quotes.
                                    " Otherwise, special characters will be escaped with carets (^).
                                    return substitute(   a:str =~# ' '       ?  '"' .  substitute(a:str, '"', '""', 'g') . '"'       : substitute(a:str, '\v([&|<>^])', '^\1', 'g'),   '%',   '%%',   'g',)
   12              0.000006     endif
                            
   12              0.000032     return shellescape (a:str)

FUNCTION  vimtex#util#count_close()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/util.vim:52
Called 1 time
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
                              " Counts the number of unopened closing patterns in the given line.
    1              0.000033   let l:i = match(a:line, a:re_close)
    1              0.000006   if l:i < 0 | return 0 | endif
                            
                              let l:sum = 0
                              while l:i >= 0
                                let l:sum += 1
                                let l:imax_first = l:i
                                let l:i += len(matchstr(a:line, a:re_close, l:i))
                                let l:i = match(a:line, a:re_close, l:i)
                              endwhile
                            
                              let l:i = match(a:line, a:re_open)
                              while l:i >= 0 && l:i < l:imax_first
                                let l:sum -= 1
                                let l:i += len(matchstr(a:line, a:re_open, l:i))
                                let l:i = match(a:line, a:re_open, l:i)
                              endwhile
                            
                              return max([l:sum, 0])

FUNCTION  gitgutter#all()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter.vim:3
Called 3 times
Total time:   0.170053
 Self time:   0.001110

count  total (s)   self (s)
    3              0.000048   let visible = tabpagebuflist()
                            
   12              0.000098   for bufnr in range(1, bufnr('$') + 1)
    9              0.000065     if buflisted(bufnr)
    6              0.000255       let file = expand('#'.bufnr.':p')
    6              0.000041       if !empty(file)
    6              0.000051         if index(visible, bufnr) != -1
    6   0.169133   0.000190           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    6              0.000012         endif
    6              0.000007       endif
    9              0.000031     endif
   12              0.000062   endfor

FUNCTION  <SNR>92_highlight_range()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:142
Called 27174 times
Total time:   1.378119
 Self time:   0.279033

count  total (s)   self (s)
                                " Set all of the positions, which are chunked into Lists which
                                " are as large as will be accepted by matchaddpos.
27174   1.354349   0.255263     call map(   ale#highlight#CreatePositions(       a:range.lnum,       a:range.col,       a:range.end_lnum,       a:range.end_col   ),   's:matchaddpos(a:group, v:val)')

FUNCTION  <SNR>75_FormatFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:156
Called 6 times
Total time:   0.000184
 Self time:   0.000092

count  total (s)   self (s)
    6              0.000010     let l:filename = a:filename
                            
    6              0.000013     if !empty(a:mappings)
                                    let l:filename = ale#filename_mapping#Map(l:filename, a:mappings)
    6              0.000002     endif
                            
    6              0.000011     if !empty(a:modifiers)
                                    let l:filename = fnamemodify(l:filename, a:modifiers)
    6              0.000003     endif
                            
    6   0.000116   0.000024     return ale#Escape(l:filename)

FUNCTION  <SNR>91_Deduplicate()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:57
Called 7 times
Total time:   4.892005
 Self time:   0.563285

count  total (s)   self (s)
    7              0.000008     let l:list = a:list
                            
    7   4.094179   0.481238     call sort(l:list, function('ale#util#LocItemCompareWithText'))
    7   0.797797   0.082018     call uniq(l:list, function('ale#util#LocItemCompareWithText'))
                            
    7              0.000007     return l:list

FUNCTION  <SNR>174_indent_conditionals()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:267
Called 1 time
Total time:   0.000113
 Self time:   0.000113

count  total (s)   self (s)
    1              0.000009   if !exists('s:re_cond')
    1              0.000009     let s:re_cond = g:vimtex_indent_conditionals
    1              0.000001   endif
                            
    1              0.000009   if empty(s:re_cond) | return 0 | endif
                            
    1              0.000008   if get(s:, 'conditional_opened')
                                if a:line =~# s:re_cond.close
                                  silent! unlet s:conditional_opened
                                  return a:prev_line =~# s:re_cond.open ? 0 : -s:sw
                                elseif a:line =~# s:re_cond.else
                                  return -s:sw
                                elseif a:prev_line =~# s:re_cond.else
                                  return s:sw
                                elseif a:prev_line =~# s:re_cond.open
                                  return s:sw
                                endif
    1              0.000001   endif
                            
    1              0.000021   if a:line =~# s:re_cond.open && a:line !~# s:re_cond.close
                                let s:conditional_opened = 1
    1              0.000002   endif
                            
    1              0.000003   return 0

FUNCTION  <SNR>34_winshell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:67
Called 3 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    3              0.000063   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  <SNR>74_StopCurrentJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:455
Called 3 times
Total time:   0.000620
 Self time:   0.000347

count  total (s)   self (s)
    3              0.000018     let l:info = get(g:ale_buffer_info, a:buffer, {})
    3   0.000299   0.000026     call ale#command#StopJobs(a:buffer, 'linter')
                            
                                " Update the active linter list, clearing out anything not running.
    3              0.000005     if a:clear_lint_file_jobs
                                    call ale#command#StopJobs(a:buffer, 'file_linter')
                                    let l:info.active_linter_list = []
    3              0.000001     else
    3              0.000008         let l:lint_file_map = {}
                            
                                    " Use a previously computed map of `lint_file` values to find
                                    " linters that are used for linting files.
   33              0.000060         for [l:lint_file, l:linter] in a:linter_slots
   30              0.000048             if l:lint_file is 1
                                            let l:lint_file_map[l:linter.name] = 1
   30              0.000022             endif
   33              0.000032         endfor
                            
                                    " Keep jobs for linting files when we're only linting buffers.
    3              0.000022         call filter(l:info.active_linter_list, 'get(l:lint_file_map, v:val.name)')
    3              0.000003     endif

FUNCTION  ale_linters#tex#chktex#Handle()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/chktex.vim:29
Called 3 times
Total time:   0.232570
 Self time:   0.082416

count  total (s)   self (s)
                                " Mattes lines like:
                                "
                                " stdin:499:2:24:Delete this space to maintain correct pagereferences.
                                " stdin:507:81:3:You should enclose the previous parenthesis with `{}'.
    3              0.000005     let l:pattern = '^stdin:\(\d\+\):\(\d\+\):\(\d\+\):\(.\+\)$'
    3              0.000003     let l:output = []
                            
11529   0.161411   0.011257     for l:match in ale#util#GetMatches(a:lines, l:pattern)
11526              0.065148         call add(l:output, {   'lnum': l:match[1] + 0,   'col': l:match[2] + 0,   'text': l:match[4] . ' (' . (l:match[3]+0) . ')',   'type': 'W',})
11529              0.004844     endfor
                            
    3              0.000003     return l:output

FUNCTION  ale#GetFilenameMappings()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:269
Called 16 times
Total time:   0.000491
 Self time:   0.000291

count  total (s)   self (s)
   16   0.000275   0.000075     let l:linter_mappings = ale#Var(a:buffer, 'filename_mappings')
                            
   16              0.000038     if type(l:linter_mappings) is v:t_list
                                    return l:linter_mappings
   16              0.000006     endif
                            
   16              0.000019     let l:name = a:name
                            
   16              0.000035     if !has_key(l:linter_mappings, l:name)
                                    " Use * as a default setting for all tools.
   16              0.000016         let l:name = '*'
   16              0.000010     endif
                            
   16              0.000034     return get(l:linter_mappings, l:name, [])

FUNCTION  <SNR>75_ExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:285
Called 9 times
Total time:  11.002794
 Self time:   0.008285

count  total (s)   self (s)
    9              0.000026     if !has_key(s:buffer_data, a:buffer)
                                    return
    9              0.000001     endif
                            
    9              0.000023     let l:jobs = s:buffer_data[a:buffer].jobs
                            
    9              0.000017     if !has_key(l:jobs, a:data.job_id)
    2              0.000002         return
    7              0.000005     endif
                            
    7              0.000017     let l:job_type = remove(l:jobs, a:data.job_id)
                            
    7              0.000010     if g:ale_history_enabled
    7   0.000423   0.000038         call ale#history#SetExitCode(a:buffer, a:data.job_id, a:data.exit_code)
                            
                                    " Log the output of the command for ALEInfo if we should.
    7              0.000014         if g:ale_history_log_output && a:data.log_output is 1
    7   0.002795   0.002430             call ale#history#RememberOutput(   a:buffer,   a:data.job_id,   a:line_list[:])
    7              0.000004         endif
    7              0.000003     endif
                            
                                " If the callback starts any new jobs, use the same job type for them.
    7              0.000023     call setbufvar(a:buffer, 'ale_job_type', l:job_type)
    7  10.996478   0.002873     let l:value = a:Callback(a:buffer, a:line_list, {   'exit_code': a:data.exit_code,   'temporary_file': a:data.temporary_file,})
                            
    7              0.000020     let l:result = a:data.result
    7              0.000015     let l:result.value = l:value
                            
                                " Set the default cwd for this buffer in this call stack.
    7   0.002715   0.002595     call ale#command#SetCwd(a:buffer, l:result.cwd)
                            
    7              0.000008     try
    7              0.000023         if get(l:result, 'result_callback', v:null) isnot v:null
                                        call call(l:result.result_callback, [l:value])
    7              0.000005         endif
    7              0.000007     finally
    7   0.000066   0.000032         call ale#command#ResetCwd(a:buffer)
    7              0.000004     endtry

FUNCTION  vimtex#delim#get_current()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/delim.vim:364
Called 9 times
Total time:   0.005196
 Self time:   0.000269

count  total (s)   self (s)
    9   0.005187   0.000260   return s:get_delim(extend({ 'direction' : 'current', 'type' : a:type, 'side' : a:side,}, get(a:, '1', {})))

FUNCTION  ale#linter#GetCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:445
Called 9 times
Total time:   0.000671
 Self time:   0.000083

count  total (s)   self (s)
    9              0.000028     let l:Command = a:linter.command
                            
    9   0.000630   0.000042     return type(l:Command) is v:t_func ? l:Command(a:buffer) : l:Command

FUNCTION  lightline#mode()
    Defined: ~/.vim/bundle/lightline.vim/autoload/lightline.vim:213
Called 19 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
   19              0.000084   return get(s:lightline.mode_map, mode(), '')

FUNCTION  <SNR>53_Lint()
    Defined: ~/.vim/bundle/ale/autoload/ale.vim:99
Called 3 times
Total time:   0.180703
 Self time:   0.000442

count  total (s)   self (s)
                                " Use the filetype from the buffer
    3              0.000018     let l:filetype = getbufvar(a:buffer, '&filetype')
    3   0.001835   0.000126     let l:linters = ale#linter#Get(l:filetype)
    3   0.000224   0.000047     let l:linters = ale#linter#RemoveIgnored(a:buffer, l:filetype, l:linters)
                            
                                " Tell other sources that they can start checking the buffer now.
    3              0.000013     let g:ale_want_results_buffer = a:buffer
    3   0.000101   0.000073     silent doautocmd <nomodeline> User ALEWantResults
    3              0.000010     unlet! g:ale_want_results_buffer
                            
                                " Don't set up buffer data and so on if there are no linters to run.
    3              0.000020     if !has_key(g:ale_buffer_info, a:buffer) && empty(l:linters)
                                    return
    3              0.000002     endif
                            
                                " Clear lint_file linters, or only run them if the file exists.
    3              0.000042     let l:lint_file = empty(l:linters)   || (a:should_lint_file && filereadable(expand('#' . a:buffer . ':p')))
                            
    3   0.178400   0.000053     call ale#engine#RunLinters(a:buffer, l:linters, l:lint_file)

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/async.vim:11
Called 6 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    6              0.000027   return s:available

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:220
Called 9 times
Total time:   0.001400
 Self time:   0.001400

count  total (s)   self (s)
    9              0.000684   let matches = matchlist(a:line, s:hunk_re)
    9              0.000090   if len(matches) > 0
    9              0.000114     let from_line  = str2nr(matches[1])
    9              0.000130     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
    9              0.000085     let to_line    = str2nr(matches[3])
    9              0.000110     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
    9              0.000141     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  ale#handlers#alex#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/alex.vim:5
Called 3 times
Total time:   0.001350
 Self time:   0.000031

count  total (s)   self (s)
    3   0.001345   0.000026     return ale#path#FindExecutable(a:buffer, 'alex', [   'node_modules/.bin/alex',   'node_modules/alex/cli.js',])

FUNCTION  <SNR>95_is_modified()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:285
Called 6 times
Total time:   0.000055
 Self time:   0.000055

count  total (s)   self (s)
    6              0.000047   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>34_unc_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:186
Called 6 times
Total time:   0.001024
 Self time:   0.000149

count  total (s)   self (s)
    6   0.001013   0.000138   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  ale_linters#tex#texlab#GetProjectRoot()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/texlab.vim:9
Called 3 times
Total time:   0.000470
 Self time:   0.000061

count  total (s)   self (s)
    3   0.000452   0.000043     let l:git_path = ale#path#FindNearestDirectory(a:buffer, '.git')
                            
    3              0.000013     return !empty(l:git_path) ? fnamemodify(l:git_path, ':h:h') : ''

FUNCTION  <SNR>87_OnInsertLeave()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:893
Called 1 time
Total time:   0.014811
 Self time:   0.002459

count  total (s)   self (s)
    1   0.000084   0.000006   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    1              0.000001   endif
                            
    1              0.000002   let s:last_char_inserted_by_user = v:false
                            
    1   0.000012   0.000008   call s:StopPoller( s:pollers.completion )
    1              0.000002   let s:force_semantic = 0
    1              0.000003   let s:completion = s:default_completion
                            
    1   0.002963   0.000007   call s:OnFileReadyToParse()
    1              0.002400   py3 ycm_state.OnInsertLeave()
    1              0.000005   if g:ycm_autoclose_preview_window_after_completion || g:ycm_autoclose_preview_window_after_insertion
                                call s:ClosePreviewWindowIfNeeded()
    1              0.000000   endif
                            
    1   0.009333   0.000019   call s:ClearSignatureHelp()

FUNCTION  ale#util#BinarySearch()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:232
Called 9 times
Total time:   0.004164
 Self time:   0.004164

count  total (s)   self (s)
    9              0.000010     let l:min = 0
    9              0.000018     let l:max = len(a:loclist) - 1
                            
  123              0.000067     while 1
  123              0.000113         if l:max < l:min
    9              0.000006             return -1
  114              0.000043         endif
                            
  114              0.000163         let l:mid = (l:min + l:max) / 2
  114              0.000657         let l:item = a:loclist[l:mid]
                            
                                    " Binary search for equal buffers, equal lines, then near columns.
  114              0.000133         if l:item.bufnr < a:buffer
                                        let l:min = l:mid + 1
  114              0.000116         elseif l:item.bufnr > a:buffer
                                        let l:max = l:mid - 1
  114              0.000120         elseif l:item.lnum < a:line
   28              0.000027             let l:min = l:mid + 1
   86              0.000085         elseif l:item.lnum > a:line
   86              0.000091             let l:max = l:mid - 1
                                    else
                                        " This part is a small sequential search.
                                        let l:index = l:mid
                            
                                        " Search backwards to find the first problem on the line.
                                        while l:index > 0&& a:loclist[l:index - 1].bufnr == a:buffer&& a:loclist[l:index - 1].lnum == a:line
                                            let l:index -= 1
                                        endwhile
                            
                                        " Find the last problem on or before this column.
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col <= a:column
                                            let l:index += 1
                                        endwhile
                            
                                        " Scan forwards to find the last item on the column for the item
                                        " we found, which will have the most serious problem.
                                        let l:item_column = a:loclist[l:index].col
                            
                                        while l:index < l:max&& a:loclist[l:index + 1].bufnr == a:buffer&& a:loclist[l:index + 1].lnum == a:line&& a:loclist[l:index + 1].col == l:item_column
                                            let l:index += 1
                                        endwhile
                            
                                        return l:index
  114              0.000048         endif
  114              0.000053     endwhile

FUNCTION  UltiSnips#TrackChange()
    Defined: ~/.vim/bundle/ultisnips/autoload/UltiSnips.vim:176
Called 1 time
Total time:   0.000146
 Self time:   0.000146

count  total (s)   self (s)
    1              0.000146     py3 UltiSnips_Manager._track_change()

FUNCTION  ale#util#GetItemPriority()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:129
Called 58395 times
Total time:   0.447618
 Self time:   0.447618

count  total (s)   self (s)
58395              0.059711     if a:item.type is# 'I'
                                    return g:ale#util#info_priority
58395              0.023239     endif
                            
58395              0.049609     if a:item.type is# 'W'
58395              0.098406         if get(a:item, 'sub_type', '') is# 'style'
                                        return g:ale#util#style_warning_priority
58395              0.023578         endif
                            
58395              0.050424         return g:ale#util#warning_priority
                                endif
                            
                                if get(a:item, 'sub_type', '') is# 'style'
                                    return g:ale#util#style_error_priority
                                endif
                            
                                return g:ale#util#error_priority

FUNCTION  ale#engine#RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:685
Called 3 times
Total time:   0.178347
 Self time:   0.000276

count  total (s)   self (s)
                                " Initialise the buffer information if needed.
    3   0.000083   0.000032     let l:new_buffer = ale#engine#InitBufferInfo(a:buffer)
                            
    3   0.178250   0.000230     call s:GetLintFileValues(   s:GetLintFileSlots(a:buffer, a:linters),   {       slots -> s:RunLinters(           a:buffer,           a:linters,           slots,           a:should_lint_file,           l:new_buffer,       )   })

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:9
Called 27 times
Total time:   0.001624
 Self time:   0.001624

count  total (s)   self (s)
   27              0.000148   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
   27              0.000256   let ggvars = getbufvar(buffer, 'gitgutter')
   27              0.000337   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
   27              0.000050   endif
   27              0.000309   let ggvars[a:varname] = a:val

FUNCTION  ale#path#FindNearestDirectory()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:52
Called 3 times
Total time:   0.000409
 Self time:   0.000409

count  total (s)   self (s)
    3              0.000061     let l:buffer_filename = fnamemodify(bufname(a:buffer), ':p')
    3              0.000031     let l:buffer_filename = fnameescape(l:buffer_filename)
                            
    3              0.000288     let l:relative_path = finddir(a:directory_name, l:buffer_filename . ';')
                            
    3              0.000008     if !empty(l:relative_path)
    3              0.000011         return fnamemodify(l:relative_path, ':p')
                                endif
                            
                                return ''

FUNCTION  <SNR>40_Highlight_Matching_Pair()
    Defined: /usr/share/vim/vim90/plugin/matchparen.vim:39
Called 20 times
Total time:   0.003172
 Self time:   0.002836

count  total (s)   self (s)
                              " Remove any previous match.
   20   0.000618   0.000282   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   20              0.000159   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   20              0.000024   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   20              0.000100   let c_lnum = line('.')
   20              0.000088   let c_col = col('.')
   20              0.000042   let before = 0
                            
   20              0.000099   let text = getline(c_lnum)
   20              0.000481   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   20              0.000080   if empty(matches)
                                let [c_before, c] = ['', '']
   20              0.000027   else
   20              0.000137     let [c_before, c] = matches[1:2]
   20              0.000025   endif
   20              0.000410   let plist = split(&matchpairs, '.\zs[:,]')
   20              0.000111   let i = index(plist, c)
   20              0.000044   if i < 0
                                " not found, in Insert mode try character before the cursor
   20              0.000119     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   20              0.000022     endif
   20              0.000040     if i < 0
                                  " not found, nothing to do
   20              0.000035       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  <SNR>95_is_modified_and_removed()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:293
Called 3 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    3              0.000025   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  ale#lsp_linter#FindProjectRoot()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:219
Called 3 times
Total time:   0.000650
 Self time:   0.000180

count  total (s)   self (s)
    3              0.000024     let l:buffer_ale_root = getbufvar(   a:buffer,   'ale_root',   getbufvar(a:buffer, 'ale_lsp_root', {}))
                            
    3              0.000006     if type(l:buffer_ale_root) is v:t_string
                                    return l:buffer_ale_root
    3              0.000002     endif
                            
                                " Try to get a buffer-local setting for the root
    3              0.000010     if has_key(l:buffer_ale_root, a:linter.name)
                                    let l:Root = l:buffer_ale_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    3              0.000003     endif
                            
    3              0.000006     let l:global_root = g:ale_root
                            
    3              0.000008     if empty(g:ale_root) && exists('g:ale_lsp_root')
                                    let l:global_root = g:ale_lsp_root
    3              0.000002     endif
                            
                                " Try to get a global setting for the root
    3              0.000006     if has_key(l:global_root, a:linter.name)
                                    let l:Root = l:global_root[a:linter.name]
                            
                                    if type(l:Root) is v:t_func
                                        return l:Root(a:buffer)
                                    else
                                        return l:Root
                                    endif
    3              0.000002     endif
                            
                                " Fall back to the linter-specific configuration
    3              0.000006     if has_key(a:linter, 'project_root')
    3              0.000009         let l:Root = a:linter.project_root
                            
    3   0.000507   0.000037         return type(l:Root) is v:t_func ? l:Root(a:buffer) : l:Root
                                endif
                            
                                return ale#util#GetFunction(a:linter.project_root_callback)(a:buffer)

FUNCTION  ale#util#FindItemAtCursor()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:485
Called 9 times
Total time:   0.004360
 Self time:   0.000196

count  total (s)   self (s)
    9              0.000032     let l:info = get(g:ale_buffer_info, a:buffer, {})
    9              0.000022     let l:loclist = get(l:info, 'loclist', [])
    9              0.000027     let l:pos = getpos('.')
    9   0.004228   0.000064     let l:index = ale#util#BinarySearch(l:loclist, a:buffer, l:pos[1], l:pos[2])
    9              0.000020     let l:loc = l:index >= 0 ? l:loclist[l:index] : {}
                            
    9              0.000015     return [l:info, l:loc]

FUNCTION  <SNR>34_restore_shell()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:207
Called 6 times
Total time:   0.001223
 Self time:   0.001223

count  total (s)   self (s)
    6              0.000201   if (has('unix') || has('win32')) && exists('s:shell')
    6              0.000947     let [&shell, &shellcmdflag, &shellredir, &shellpipe, &shellquote, &shellxquote] = [s:shell, s:shellcmdflag, s:shellredir, s:shellpipe, s:shellquote, s:shellxquote]
    6              0.000013   endif

FUNCTION  <SNR>87_InsideCommentOrString()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:942
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                              " Has to be col('.') -1 because col('.') doesn't exist at this point. We are
                              " in insert mode when this func is called.
    1              0.000007   let syntax_group = synIDattr( synIDtrans( synID( line( '.' ), col( '.' ) - 1, 1 ) ), 'name')
                            
    1              0.000002   if stridx(syntax_group, 'Comment') > -1
                                return 1
    1              0.000000   endif
                            
    1              0.000002   if stridx(syntax_group, 'String') > -1
                                return 2
    1              0.000000   endif
                            
    1              0.000001   return 0

FUNCTION  <SNR>97_handle_double_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/sign.vim:212
Called 3 times
Total time:   0.000133
 Self time:   0.000133

count  total (s)   self (s)
    3              0.000084   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    3              0.000005   endif
                            
    3              0.000009   return a:modified_lines

FUNCTION  <SNR>95_process_hunk()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:244
Called 9 times
Total time:   0.005595
 Self time:   0.002239

count  total (s)   self (s)
    9              0.000052   let modifications = []
    9              0.000058   let from_line  = a:hunk[0]
    9              0.000054   let from_count = a:hunk[1]
    9              0.000055   let to_line    = a:hunk[2]
    9              0.000066   let to_count   = a:hunk[3]
                            
    9   0.000246   0.000176   if s:is_added(from_count, to_count)
    3   0.000285   0.000079     call s:process_added(modifications, from_count, to_count, to_line)
    3   0.000559   0.000063     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
    6   0.000158   0.000111   elseif s:is_removed(from_count, to_count)
                                call s:process_removed(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
    6   0.000169   0.000114   elseif s:is_modified(from_count, to_count)
    3   0.000317   0.000071     call s:process_modified(modifications, from_count, to_count, to_line)
    3   0.000670   0.000066     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
    3   0.000088   0.000057   elseif s:is_modified_and_added(from_count, to_count)
                                call s:process_modified_and_added(modifications, from_count, to_count, to_line)
                                call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
                                call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    3   0.000091   0.000059   elseif s:is_modified_and_removed(from_count, to_count)
    3   0.000668   0.000096     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    3   0.000558   0.000061     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    3   0.000570   0.000070     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
    9              0.000015   endif
    9              0.000029   return modifications

FUNCTION  <SNR>74_RunLinter()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:585
Called 30 times
Total time:   0.121137
 Self time:   0.000683

count  total (s)   self (s)
   30              0.000065     if !empty(a:linter.lsp)
    3   0.001239   0.000015         return ale#lsp_linter#CheckWithLSP(a:buffer, a:linter)
   27              0.000011     else
   27   0.005648   0.000156         let l:executable = ale#linter#GetExecutable(a:buffer, a:linter)
                            
   27   0.114083   0.000345         return s:RunIfExecutable(a:buffer, a:linter, a:lint_file, l:executable)
                                endif
                            
                                return 0

FUNCTION  vimtex#util#count_open()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/util.vim:28
Called 1 time
Total time:   0.000440
 Self time:   0.000440

count  total (s)   self (s)
                              " Counts the number of unclosed opening patterns in the given line.
    1              0.000112   let l:i = match(a:line, a:re_open)
    1              0.000009   if l:i < 0 | return 0 | endif
                            
    1              0.000004   let l:sum = 0
    1              0.000005   let l:imin_last = l:i
    2              0.000008   while l:i >= 0
    1              0.000005     let l:sum += 1
    1              0.000044     let l:i += len(matchstr(a:line, a:re_open, l:i))
    1              0.000048     let l:i = match(a:line, a:re_open, l:i)
    2              0.000005   endwhile
                            
    1              0.000063   let l:i = match(a:line, a:re_close, l:imin_last)
    2              0.000008   while l:i >= 0
    1              0.000004     let l:sum -= 1
    1              0.000038     let l:i += len(matchstr(a:line, a:re_close, l:i))
    1              0.000032     let l:i = match(a:line, a:re_close, l:i)
    2              0.000005   endwhile
                            
    1              0.000008   return max([l:sum, 0])

FUNCTION  ale#command#InitData()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:22
Called 25 times
Total time:   0.000277
 Self time:   0.000277

count  total (s)   self (s)
   25              0.000146     if !has_key(s:buffer_data, a:buffer)
    1              0.000004         let s:buffer_data[a:buffer] = {   'jobs': {},   'file_list': [],   'directory_list': [],}
   25              0.000014     endif

FUNCTION  ale#util#LocItemCompare()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:151
Called 509764 times
Total time:   6.638072
 Self time:   6.453866

count  total (s)   self (s)
509764              0.521228     if a:left.bufnr < a:right.bufnr
                                    return -1
509764              0.202935     endif
                            
509764              0.485248     if a:left.bufnr > a:right.bufnr
                                    return 1
509764              0.196540     endif
                            
509764              0.408639     if a:left.bufnr == -1
                                    if a:left.filename < a:right.filename
                                        return -1
                                    endif
                            
                                    if a:left.filename > a:right.filename
                                        return 1
                                    endif
509764              0.182436     endif
                            
509764              0.498179     if a:left.lnum < a:right.lnum
430846              0.258948         return -1
78918              0.029050     endif
                            
78918              0.076019     if a:left.lnum > a:right.lnum
22596              0.013221         return 1
56322              0.020597     endif
                            
56322              0.056270     if a:left.col < a:right.col
42396              0.025389         return -1
13926              0.005004     endif
                            
13926              0.013410     if a:left.col > a:right.col
 1658              0.001020         return 1
12268              0.004441     endif
                            
                                " When either of the items lacks a problem type, then the two items should
                                " be considered equal. This is important for loclist jumping.
12268              0.027585     if !has_key(a:left, 'type') || !has_key(a:right, 'type')
                                    return 0
12268              0.004644     endif
                            
12268   0.138435   0.046405     let l:left_priority = ale#util#GetItemPriority(a:left)
12268   0.139005   0.046829     let l:right_priority = ale#util#GetItemPriority(a:right)
                            
12268              0.015031     if l:left_priority < l:right_priority
                                    return -1
12268              0.004531     endif
                            
12268              0.014417     if l:left_priority > l:right_priority
                                    return 1
12268              0.004689     endif
                            
12268              0.007696     return 0

FUNCTION  <SNR>91_CloseWindowIfNeeded()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:242
Called 3 times
Total time:   0.000096
 Self time:   0.000027

count  total (s)   self (s)
    3   0.000092   0.000023     if ale#Var(a:buffer, 'keep_list_window_open') || s:ShouldClose(a:buffer)
    3              0.000000         return
                                endif
                            
                                let l:did_close_any_list = 0
                            
                                try
                                    " Only close windows if the quickfix list or loclist is completely empty,
                                    " including errors set through other means.
                                    if g:ale_set_quickfix
                                        if empty(getqflist())
                                            cclose
                                            let l:did_close_any_list = 1
                                        endif
                                    else
                                        let l:win_ids = s:WinFindBuf(a:buffer)
                            
                                        for l:win_id in l:win_ids
                                            if g:ale_set_loclist && empty(getloclist(l:win_id))
                                                lclose
                                                let l:did_close_any_list = 1
                                            endif
                                        endfor
                                    endif
                                " Ignore 'Cannot close last window' errors.
                                catch /E444/
                                endtry
                            
                                if l:did_close_any_list
                                    call s:RestoreViewIfNeeded(a:buffer)
                                endif

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:112
Called 24 times
Total time:   0.001340
 Self time:   0.000596

count  total (s)   self (s)
   24   0.001041   0.000383   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   24   0.000256   0.000170   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  vimtex#syntax#stack()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/syntax.vim:7
Called 9 times
Total time:   0.001172
 Self time:   0.001172

count  total (s)   self (s)
    9              0.000108   let l:pos = a:0 > 0 ? [a:1, a:2] : [line('.'), col('.')]
    9              0.000041   if mode() ==# 'i'
    1              0.000002     let l:pos[1] -= 1
    9              0.000010   endif
    9              0.000128   call map(l:pos, 'max([v:val, 1])')
                            
    9              0.000832   return map(synstack(l:pos[0], l:pos[1]), "synIDattr(v:val, 'name')")

FUNCTION  <SNR>91_ShouldClose()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:50
Called 3 times
Total time:   0.000045
 Self time:   0.000025

count  total (s)   self (s)
    3   0.000030   0.000010     let l:val = ale#Var(a:buffer, 'open_list')
    3              0.000008     let l:saved = getbufvar(a:buffer, 'ale_save_event_fired', 0)
                            
    3              0.000006     return !((l:val >= 1) || (l:val is# 'on_save' && l:saved))

FUNCTION  <SNR>88_StopCursorTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:65
Called 8 times
Total time:   0.000125
 Self time:   0.000125

count  total (s)   self (s)
    8              0.000028     if s:cursor_timer != -1
    8              0.000044         call timer_stop(s:cursor_timer)
    8              0.000027         let s:cursor_timer = -1
    8              0.000009     endif

FUNCTION  ale#command#ManageDirectory()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:50
Called 9 times
Total time:   0.000173
 Self time:   0.000089

count  total (s)   self (s)
    9   0.000127   0.000043     call ale#command#InitData(a:buffer)
    9              0.000035     call add(s:buffer_data[a:buffer].directory_list, a:directory)

FUNCTION  <SNR>34_is_file_buffer()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:62
Called 6 times
Total time:   0.000101
 Self time:   0.000101

count  total (s)   self (s)
    6              0.000084   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:253
Called 6 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    6              0.000136   return has('win64') || has('win32') || has('win16')

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:20
Called 12 times
Total time:   0.000887
 Self time:   0.000411

count  total (s)   self (s)
   12   0.000877   0.000401   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  ale#linter#GetAll()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:277
Called 3 times
Total time:   0.000257
 Self time:   0.000201

count  total (s)   self (s)
                                " Don't return linters in the sandbox.
                                " Otherwise a sandboxed script could modify them.
    3   0.000074   0.000018     if ale#util#InSandbox()
                                    return []
    3              0.000002     endif
                            
    3              0.000007     let l:combined_linters = []
                            
    6              0.000015     for l:filetype in a:filetypes
                                    " Load linters from runtimepath if we haven't done that yet.
    3              0.000017         if !has_key(s:runtime_loaded_map, l:filetype)
                                        execute 'silent! runtime! ale_linters/' . l:filetype . '/*.vim'
                            
                                        let s:runtime_loaded_map[l:filetype] = 1
    3              0.000003         endif
                            
    3              0.000045         call extend(l:combined_linters, get(s:linters, l:filetype, []))
    6              0.000007     endfor
                            
    3              0.000006     return l:combined_linters

FUNCTION  ale#linter#ResolveFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:326
Called 3 times
Total time:   0.000312
 Self time:   0.000083

count  total (s)   self (s)
    3   0.000288   0.000059     let l:filetype = s:GetAliasedFiletype(a:original_filetype)
                            
    3              0.000012     if type(l:filetype) isnot v:t_list
    3              0.000007         return [l:filetype]
                                endif
                            
                                return l:filetype

FUNCTION  <SNR>91_WinFindBuf()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:96
Called 7 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    7              0.000040     return exists('*win_findbuf') ? win_findbuf(str2nr(a:buffer)) : [0]

FUNCTION  <SNR>95_process_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:297
Called 3 times
Total time:   0.000206
 Self time:   0.000206

count  total (s)   self (s)
    3              0.000013   let offset = 0
    6              0.000024   while offset < a:to_count
    3              0.000017     let line_number = a:to_line + offset
    3              0.000060     call add(a:modifications, [line_number, 'added'])
    3              0.000015     let offset += 1
    6              0.000020   endwhile

FUNCTION  <SNR>80_VimExitCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:114
Called 9 times
Total time:  11.003387
 Self time:   0.000378

count  total (s)   self (s)
    9   0.000083   0.000047     let l:job_id = ale#job#ParseVim8ProcessID(string(a:job))
    9              0.000024     let l:info = get(s:job_map, l:job_id, {})
                            
    9              0.000013     if empty(l:info)
                                    return
    9              0.000005     endif
                            
    9              0.000017     let l:info.exit_code = a:exit_code
                            
                                " The program can exit before the data has finished being read.
    9              0.000028     if ch_status(job_getchannel(a:job)) is# 'closed'
    9              0.000009         try
    9              0.000025             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
    9  11.003064   0.000091                 call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, a:exit_code)
    9              0.000002             endif
    9              0.000006         finally
                                        " Automatically forget about the job after it's done.
    9              0.000025             if has_key(s:job_map, l:job_id)
    9              0.000024                 call remove(s:job_map, l:job_id)
    9              0.000004             endif
    9              0.000004         endtry
    9              0.000004     endif

FUNCTION  <SNR>74_RunLinters()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:644
Called 3 times
Total time:   0.175951
 Self time:   0.000995

count  total (s)   self (s)
    3   0.000654   0.000034     call s:StopCurrentJobs(a:buffer, a:should_lint_file, a:slots)
    3   0.053189   0.000045     call s:RemoveProblemsForDisabledLinters(a:buffer, a:linters)
                            
                                " We can only clear the results if we aren't checking the buffer.
    3   0.000189   0.000145     let l:can_clear_results = !ale#engine#IsCheckingBuffer(a:buffer)
                            
    3   0.000047   0.000036     silent doautocmd <nomodeline> User ALELintPre
                            
   33              0.000082     for [l:lint_file, l:linter] in a:slots
                                    " Only run lint_file linters if we should.
   30              0.000045         if !l:lint_file || a:should_lint_file
   30   0.121475   0.000338             if s:RunLinter(a:buffer, l:linter, l:lint_file)
                                            " If a single linter ran, we shouldn't clear everything.
    9              0.000019                 let l:can_clear_results = 0
   30              0.000015             endif
                                    else
                                        " If we skipped running a lint_file linter still in the list,
                                        " we shouldn't clear everything.
                                        let l:can_clear_results = 0
   30              0.000014         endif
   33              0.000038     endfor
                            
                                " Clear the results if we can. This needs to be done when linters are
                                " disabled, or ALE itself is disabled.
    3              0.000003     if l:can_clear_results
                                    call ale#engine#SetResults(a:buffer, [])
    3              0.000003     elseif a:new_buffer
                                    call s:AddProblemsFromOtherBuffers(   a:buffer,   map(copy(a:slots), 'v:val[1]'))
    3              0.000001     endif

FUNCTION  ale#sign#GetSignCommands()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:376
Called 7 times
Total time:   0.636013
 Self time:   0.612486

count  total (s)   self (s)
    7              0.000009     let l:command_list = []
    7              0.000011     let l:is_dummy_sign_set = a:was_sign_set
                            
                                " Set the dummy sign if we need to.
                                " The dummy sign is needed to keep the sign column open while we add
                                " and remove signs.
    7              0.000027     if !l:is_dummy_sign_set && (!empty(a:sign_map) || g:ale_sign_column_always)
    7   0.000138   0.000091         call add(l:command_list, 'sign place '   .  g:ale_sign_offset   . s:GroupCmd()   . s:PriorityCmd()   . ' line=1 name=ALEDummySign '   . ' buffer=' . a:buffer)
    7              0.000008         let l:is_dummy_sign_set = 1
    7              0.000005     endif
                            
                                " Place new items first.
24116              0.030370     for [l:line_str, l:info] in items(a:sign_map)
24109              0.019109         if l:info.new_id
                                        " Save the sign IDs we are setting back on our loclist objects.
                                        " These IDs will be used to preserve items which are set many times.
54339              0.040804             for l:item in l:info.items
33859              0.038576                 let l:item.sign_id = l:info.new_id
54339              0.021956             endfor
                            
20480              0.032896             if index(l:info.current_id_list, l:info.new_id) < 0
 3629   0.048177   0.031822                 call add(l:command_list, 'sign place '   . (l:info.new_id)   . s:GroupCmd()   . s:PriorityCmd()   . ' line=' . l:line_str   . ' name=' . (l:info.new_name)   . ' buffer=' . a:buffer)
20480              0.008285             endif
24109              0.009037         endif
24116              0.009716     endfor
                            
                                " Remove signs without new IDs.
24116              0.016338     for l:info in values(a:sign_map)
44589              0.036989         for l:current_id in l:info.current_id_list
20480              0.021770             if l:current_id isnot l:info.new_id
 3629   0.025722   0.018619                 call add(l:command_list, 'sign unplace '   . l:current_id   . s:GroupCmd()   . ' buffer=' . a:buffer)
20480              0.007977             endif
44589              0.017259         endfor
24116              0.008923     endfor
                            
                                " Remove the dummy sign to close the sign column if we need to.
    7              0.000016     if l:is_dummy_sign_set && !g:ale_sign_column_always
    7   0.000659   0.000637         call add(l:command_list, 'sign unplace '   . g:ale_sign_offset   . s:GroupCmd()   . ' buffer=' . a:buffer)
    7              0.000006     endif
                            
    7              0.000007     return l:command_list

FUNCTION  <SNR>190_HandleUnixFormat()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/unix.vim:4
Called 1 time
Total time:   0.001017
 Self time:   0.000274

count  total (s)   self (s)
    1              0.000001     let l:pattern = '\v^[a-zA-Z]?:?[^:]+:(\d+):?(\d+)?:? ?(.+)$'
    1              0.000001     let l:output = []
                            
   41   0.000788   0.000045     for l:match in ale#util#GetMatches(a:lines, l:pattern)
   40              0.000200         call add(l:output, {   'lnum': l:match[1] + 0,   'col': l:match[2] + 0,   'text': l:match[3],   'type': a:type,})
   41              0.000018     endfor
                            
    1              0.000001     return l:output

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:40
Called 3 times
Total time:   0.000500
 Self time:   0.000128

count  total (s)   self (s)
    3   0.000269   0.000048   let summary = gitgutter#hunk#summary(a:bufnr)
    3              0.000016   let summary[2] += a:count
    3   0.000203   0.000052   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>92_matchaddpos()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:109
Called 27174 times
Total time:   0.987817
 Self time:   0.987817

count  total (s)   self (s)
27174              0.026524     if s:has_nvim_highlight
                                    for l:pos in a:pos_list
                                        let l:line = type(l:pos) == v:t_number   ? l:pos - 1   : l:pos[0] - 1
                            
                                        if type(l:pos) == v:t_number || len(l:pos) == 1
                                            let l:col_start = 0
                                            let l:col_end = s:MAX_COL_SIZE
                                        else
                                            let l:col_start = l:pos[1] - 1
                                            let l:col_end = l:col_start + get(l:pos, 2, 1)
                                        endif
                            
                                        call ale#highlight#nvim_buf_add_highlight(   bufnr(''),   s:ns_id,   a:group,   l:line,   l:col_start,   l:col_end,)
                                    endfor
27174              0.011912     else
27174              0.567673         call matchaddpos(a:group, a:pos_list)
27174              0.012356     endif

FUNCTION  ale#list#SetLists()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:207
Called 7 times
Total time:   0.000271
 Self time:   0.000180

count  total (s)   self (s)
    7              0.000056     if get(g:, 'ale_set_lists_synchronously') == 1|| getbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Update lists immediately if running a test synchronously, or if the
                                    " buffer was saved.
                                    "
                                    " The lists need to be updated immediately when saving a buffer so
                                    " that we can reliably close window automatically, if so configured.
                                    call s:SetListsImpl(-1, a:buffer, a:loclist)
    7              0.000006     else
    7   0.000163   0.000072         call ale#util#StartPartialTimer(   0,   function('s:SetListsImpl'),   [a:buffer, a:loclist],)
    7              0.000002     endif

FUNCTION  ale#util#InSandbox()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:290
Called 30 times
Total time:   0.000468
 Self time:   0.000468

count  total (s)   self (s)
   30              0.000049     try
   30              0.000201         let &l:equalprg=&l:equalprg
                                catch /E48/
                                    " E48 is the sandbox error.
                                    return 1
   30              0.000034     endtry
                            
   30              0.000044     return 0

FUNCTION  vimtex#pos#get_cursor()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/pos.vim:12
Called 9 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
    9              0.000044   return getcurpos()

FUNCTION  ale#util#GetLineCount()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:84
Called 7 times
Total time:   0.010037
 Self time:   0.010037

count  total (s)   self (s)
    7              0.010034     return len(getbufline(a:buffer, 1, '$'))

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:71
Called 6 times
Total time:   0.118806
 Self time:   0.001957

count  total (s)   self (s)
    6   0.000436   0.000105   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter path not set'
    6              0.000008   endif
                            
    6   0.000321   0.000071   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
    2              2.509145     throw 'gitgutter not tracked'
    3              0.000003   endif
                            
    3   0.000144   0.000038   if gitgutter#utility#repo_path(a:bufnr, 0) == -3
                                throw 'gitgutter assume unchanged'
    3              0.000003   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    3              0.000009   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    3              0.000023   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    3              0.000023   let s:counter = (s:counter + 1) % 20
    3              0.000020   let buff_file .= '.'.s:counter
                            
    3   0.000319   0.000039   let extension = gitgutter#utility#extension(a:bufnr)
    3              0.000016   if !empty(extension)
    3              0.000017     let buff_file .= '.'.extension
    3              0.000004   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    3   0.066215   0.000160   call s:write_buffer(a:bufnr, buff_file)
                            
    3              0.000024   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    3              0.000050     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    3              0.000033     let from_file .= '.'.s:counter
                            
    3              0.000023     if !empty(extension)
    3              0.000018       let from_file .= '.'.extension
    3              0.000005     endif
                            
                                " Write file from index to temporary file.
    3   0.000886   0.000173     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000055     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    3              0.000006   endif
                            
                              " Call git-diff.
    3              0.000028   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    3              0.000008   if s:c_flag
    3              0.000015     let cmd .= ' -c "diff.autorefreshindex=0"'
    3              0.000013     let cmd .= ' -c "diff.noprefix=false"'
    3              0.000013     let cmd .= ' -c "core.safecrlf=false"'
    3              0.000005   endif
    3              0.000039   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    3              0.000025   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    3   0.000403   0.000152     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    3              0.000028   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    3              0.000019   let cmd .= ' || exit 0'
                            
    3              0.000017   let cmd .= ')'
                            
    3   0.001492   0.000056   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    3   0.000073   0.000053   if g:gitgutter_async && gitgutter#async#available()
                                call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
                                return 'async'
                            
    3              0.000005   else
    3   0.047502   0.000095     let diff = gitgutter#utility#system(cmd)
                            
    3              0.000013     if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
    3              0.000006     endif
                            
    3              0.000016     return diff
                              endif

FUNCTION  ale#engine#FixLocList()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:259
Called 7 times
Total time:   1.089730
 Self time:   1.079385

count  total (s)   self (s)
    7   0.000266   0.000046     let l:mappings = ale#GetFilenameMappings(a:buffer, a:linter_name)
                            
    7              0.000010     if !empty(l:mappings)
                                    " We need to apply reverse filename mapping here.
                                    let l:mappings = ale#filename_mapping#Invert(l:mappings)
    7              0.000003     endif
                            
    7              0.000009     let l:bufnr_map = {}
    7              0.000007     let l:new_loclist = []
                            
                                " Some errors have line numbers beyond the end of the file,
                                " so we need to adjust them so they set the error at the last line
                                " of the file instead.
    7   0.010083   0.000046     let l:last_line_number = ale#util#GetLineCount(a:buffer)
                            
14438              0.010676     for l:old_item in a:loclist
                                    " Copy the loclist item with some default values and corrections.
                                    "
                                    " line and column numbers will be converted to numbers.
                                    " The buffer will default to the buffer being checked.
                                    " The vcol setting will default to 0, a byte index.
                                    " The error type will default to 'E' for errors.
                                    " The error number will default to -1.
                                    "
                                    " The line number and text are the only required keys.
                                    "
                                    " The linter_name will be set on the errors so it can be used in
                                    " output, filtering, etc..
14431              0.129043         let l:item = {   'bufnr': a:buffer,   'text': l:old_item.text,   'lnum': str2nr(l:old_item.lnum),   'col': str2nr(get(l:old_item, 'col', 0)),   'vcol': 0,   'type': get(l:old_item, 'type', 'E'),   'nr': get(l:old_item, 'nr', -1),   'linter_name': a:linter_name,}
                            
14431              0.013909         if a:from_other_source
                                        let l:item.from_other_source = 1
14431              0.005754         endif
                            
14431              0.020327         if has_key(l:old_item, 'code')
                                        let l:item.code = l:old_item.code
14431              0.005651         endif
                            
14431              0.027718         let l:old_name = get(l:old_item, 'filename', '')
                            
                                    " Map parsed from output to local filesystem files.
14431              0.026448         if !empty(l:old_name) && !empty(l:mappings)
                                        let l:old_name = ale#filename_mapping#Map(l:old_name, l:mappings)
14431              0.005309         endif
                            
14431              0.027545         if !empty(l:old_name) && !ale#path#IsTempName(l:old_name)
                                        " Use the filename given.
                                        " Temporary files are assumed to be for this buffer,
                                        " and the filename is not included then, because it looks bad
                                        " in the loclist window.
                                        let l:filename = l:old_name
                                        let l:item.filename = l:filename
                            
                                        if has_key(l:old_item, 'bufnr')
                                            " If a buffer number is also given, include that too.
                                            " If Vim detects that he buffer number is valid, it will
                                            " be used instead of the filename.
                                            let l:item.bufnr = l:old_item.bufnr
                                        elseif has_key(l:bufnr_map, l:filename)
                                            " Get the buffer number from the map, which can be faster.
                                            let l:item.bufnr = l:bufnr_map[l:filename]
                                        else
                                            " Look up the buffer number.
                                            let l:item.bufnr = bufnr(l:filename)
                                            let l:bufnr_map[l:filename] = l:item.bufnr
                                        endif
14431              0.020433         elseif has_key(l:old_item, 'bufnr')
                                        let l:item.bufnr = l:old_item.bufnr
14431              0.005045         endif
                            
14431              0.019979         if has_key(l:old_item, 'detail')
                                        let l:item.detail = l:old_item.detail
14431              0.005493         endif
                            
                                    " Pass on a end_col key if set, used for highlights.
14431              0.019757         if has_key(l:old_item, 'end_col')
                                        let l:item.end_col = str2nr(l:old_item.end_col)
14431              0.004898         endif
                            
14431              0.019789         if has_key(l:old_item, 'end_lnum')
                                        let l:item.end_lnum = str2nr(l:old_item.end_lnum)
                            
                                        " When the error ends after the end of the file, put it at the
                                        " end. This is only done for the current buffer.
                                        if l:item.bufnr == a:buffer && l:item.end_lnum > l:last_line_number
                                            let l:item.end_lnum = l:last_line_number
                                        endif
14431              0.005152         endif
                            
14431              0.019267         if has_key(l:old_item, 'sub_type')
                                        let l:item.sub_type = l:old_item.sub_type
14431              0.005549         endif
                            
14431              0.012812         if l:item.lnum < 1
                                        " When errors appear before line 1, put them at line 1.
                                        let l:item.lnum = 1
14431              0.024979         elseif l:item.bufnr == a:buffer && l:item.lnum > l:last_line_number
                                        " When errors go beyond the end of the file, put them at the end.
                                        " This is only done for the current buffer.
    3              0.000005             let l:item.lnum = l:last_line_number
14428              0.021339         elseif get(l:old_item, 'vcol', 0)
                                        " Convert virtual column positions to byte positions.
                                        " The positions will be off if the buffer has changed recently.
                                        let l:line = getbufline(a:buffer, l:item.lnum)[0]
                            
                                        let l:item.col = ale#util#Col(l:line, l:item.col)
                            
                                        if has_key(l:item, 'end_col')
                                            let l:end_line = get(l:item, 'end_lnum', l:line) != l:line   ? getbufline(a:buffer, l:item.end_lnum)[0]   : l:line
                            
                                            let l:item.end_col = ale#util#Col(l:end_line, l:item.end_col)
                                        endif
14431              0.005591         endif
                            
14431              0.022677         call add(l:new_loclist, l:item)
14438              0.006722     endfor
                            
    7   0.000240   0.000152     let l:type_map = get(ale#Var(a:buffer, 'type_map'), a:linter_name, {})
                            
    7              0.000012     if !empty(l:type_map)
                                    call s:RemapItemTypes(l:type_map, l:new_loclist)
    7              0.000003     endif
                            
    7              0.000007     return l:new_loclist

FUNCTION  <SNR>144_get_delim()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/delim.vim:484
Called 9 times
Total time:   0.004927
 Self time:   0.004336

count  total (s)   self (s)
                              "
                              " Arguments:
                              "   opts = {
                              "     'direction'   :  next
                              "                      prev
                              "                      current
                              "     'type'        :  env_tex
                              "                      env_math
                              "                      env_all
                              "                      delim_tex
                              "                      delim_math
                              "                      delim_modq_math (possibly modified math delimiter)
                              "                      delim_mod_math  (modified math delimiter)
                              "                      delim_all
                              "                      all
                              "     'side'        :  open
                              "                      close
                              "                      both
                              "     'syn_exclude' :  Don't match in given syntax
                              "  }
                              "
                              " Returns:
                              "   delim = {
                              "     type    : env | delim
                              "     side    : open | close
                              "     name    : name of environment [only for type env]
                              "     lnum    : number
                              "     cnum    : number
                              "     match   : unparsed matched delimiter
                              "     corr    : corresponding delimiter
                              "     re : {
                              "       open  : regexp for the opening part
                              "       close : regexp for the closing part
                              "     }
                              "     remove  : method to remove the delimiter
                              "   }
                              "
    9   0.000147   0.000095   let l:save_pos = vimtex#pos#get_cursor()
    9              0.000074   let l:re = g:vimtex#delim#re[a:opts.type][a:opts.side]
    9              0.000021   while 1
    9              0.000940     let [l:lnum, l:cnum] = a:opts.direction ==# 'next' ? searchpos(l:re, 'cnW', line('.') + g:vimtex_delim_stopline) : a:opts.direction ==# 'prev'   ? searchpos(l:re, 'bcnW', max([line('.') - g:vimtex_delim_stopline, 1]))   : searchpos(l:re, 'bcnW', line('.'))
    9              0.000062     if l:lnum == 0 | break | endif
                            
                                if has_key(a:opts, 'syn_exclude') && vimtex#syntax#in(a:opts.syn_exclude, l:lnum, l:cnum)
                                  call vimtex#pos#set_cursor(vimtex#pos#prev(l:lnum, l:cnum))
                                  continue
                                endif
                            
                                break
    9              0.000019   endwhile
    9   0.000653   0.000114   call vimtex#pos#set_cursor(l:save_pos)
                            
    9              0.000543   let l:match = matchstr(getline(l:lnum), '^' . l:re, l:cnum-1)
                            
    9              0.000121   if a:opts.direction ==# 'current' && l:cnum + strlen(l:match) + (mode() ==# 'i' ? 1 : 0) <= col('.')
    9              0.000024     let l:match = ''
    9              0.000018     let l:lnum = 0
    9              0.000015     let l:cnum = 0
    9              0.000011   endif
                            
    9              0.000187   let l:result = { 'type' : '', 'lnum' : l:lnum, 'cnum' : l:cnum, 'match' : l:match, 'remove' : function('s:delim_remove'),}
                            
   54              0.000123   for l:type in s:types
   45              0.000692     if l:match =~# '^' . l:type.re
                                  let l:result = extend( l:type.parser(l:match, l:lnum, l:cnum,               a:opts.side, a:opts.type, a:opts.direction), l:result, 'keep')
                                  break
   45              0.000043     endif
   54              0.000073   endfor
                            
    9              0.000096   return empty(l:result.type) ? {} : l:result

FUNCTION  <SNR>55_GetAliasedFiletype()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:300
Called 3 times
Total time:   0.000229
 Self time:   0.000229

count  total (s)   self (s)
    3              0.000024     let l:buffer_aliases = get(b:, 'ale_linter_aliases', {})
                            
                                " b:ale_linter_aliases can be set to a List or String.
    3              0.000027     if type(l:buffer_aliases) is v:t_list|| type(l:buffer_aliases) is v:t_string
                                    return l:buffer_aliases
    3              0.000004     endif
                            
                                " Check for aliased filetypes first in a buffer variable,
                                " then the global variable,
                                " then in the default mapping,
                                " otherwise use the original filetype.
   12              0.000038     for l:dict in [   l:buffer_aliases,   g:ale_linter_aliases,   s:default_ale_linter_aliases,]
    9              0.000033         if has_key(l:dict, a:original_filetype)
                                        return l:dict[a:original_filetype]
    9              0.000008         endif
   12              0.000017     endfor
                            
    3              0.000006     return a:original_filetype

FUNCTION  ale#highlight#SetHighlights()
    Defined: ~/.vim/bundle/ale/autoload/ale/highlight.vim:225
Called 7 times
Total time:   2.229420
 Self time:   0.049069

count  total (s)   self (s)
    7              0.037494     let l:new_list = getbufvar(a:buffer, 'ale_enabled', 1) && g:ale_enabled   ? filter(copy(a:loclist), 'v:val.bufnr == a:buffer && v:val.col > 0')   : []
                            
                                " Set the list in the buffer variable.
    7              0.006985     call setbufvar(str2nr(a:buffer), 'ale_highlight_items', l:new_list)
                            
    7   0.004588   0.004485     let l:exclude_list = ale#Var(a:buffer, 'exclude_highlights')
                            
    7              0.000015     if !empty(l:exclude_list)
                                    call filter(l:new_list, 'empty(ale#util#GetMatches(v:val.text, l:exclude_list))')
    7              0.000005     endif
                            
                                " Update highlights for the current buffer, which may or may not
                                " be the buffer we just set highlights for.
    7   2.180288   0.000040     call ale#highlight#UpdateHighlights()

FUNCTION  <SNR>34_dir()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:231
Called 12 times
Total time:   0.002104
 Self time:   0.000427

count  total (s)   self (s)
   12   0.002089   0.000412   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  ale#engine#SetResults()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:184
Called 7 times
Total time:   6.203901
 Self time:   0.022467

count  total (s)   self (s)
    7   0.000111   0.000036     let l:linting_is_done = !ale#engine#IsCheckingBuffer(a:buffer)
                            
                                " Set signs first. This could potentially fix some line numbers.
                                " The List could be sorted again here by SetSigns.
    7              0.000007     if g:ale_set_signs
    7   3.968700   0.017737         call ale#sign#SetSigns(a:buffer, a:loclist)
    7              0.000006     endif
                            
    7              0.000017     if g:ale_set_quickfix || g:ale_set_loclist
    7   0.004640   0.004369         call ale#list#SetLists(a:buffer, a:loclist)
    7              0.000004     endif
                            
    7              0.000017     if exists('*ale#statusline#Update')
                                    " Don't load/run if not already loaded.
                                    call ale#statusline#Update(a:buffer, a:loclist)
    7              0.000004     endif
                            
    7              0.000007     if g:ale_set_highlights
    7   2.229467   0.000047         call ale#highlight#SetHighlights(a:buffer, a:loclist)
    7              0.000003     endif
                            
    7              0.000007     if l:linting_is_done
    1              0.000001         if g:ale_echo_cursor
                                        " Try and echo the warning now.
                                        " This will only do something meaningful if we're in normal mode.
    1   0.000018   0.000008             call ale#cursor#EchoCursorWarning()
    1              0.000000         endif
                            
    1              0.000001         if g:ale_virtualtext_cursor
                                        " Try and show the warning now.
                                        " This will only do something meaningful if we're in normal mode.
                                        call ale#virtualtext#ShowCursorWarning()
    1              0.000000         endif
                            
                                    " Reset the save event marker, used for opening windows, etc.
    1              0.000003         call setbufvar(a:buffer, 'ale_save_event_fired', 0)
                                    " Set a marker showing how many times a buffer has been checked.
    1              0.000003         call setbufvar(   a:buffer,   'ale_linted',   getbufvar(a:buffer, 'ale_linted', 0) + 1)
                            
                                    " Automatically remove all managed temporary files and directories
                                    " now that all jobs have completed.
    1   0.000694   0.000007         call ale#command#RemoveManagedFiles(a:buffer)
                            
                                    " Call user autocommands. This allows users to hook into ALE's lint cycle.
    1   0.000020   0.000012         silent doautocmd <nomodeline> User ALELintPost
    7              0.000004     endif

FUNCTION  <SNR>95_is_modified_and_added()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:289
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    3              0.000025   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  ale#handlers#writegood#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/handlers/writegood.vim:13
Called 3 times
Total time:   0.001148
 Self time:   0.000020

count  total (s)   self (s)
    3   0.001145   0.000017     return ale#path#FindExecutable(a:buffer, 'writegood', [   'node_modules/.bin/write-good',   'node_modules/write-good/bin/write-good.js',])

FUNCTION  ale#sign#GetSignName()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:118
Called 20480 times
Total time:   0.769479
 Self time:   0.506067

count  total (s)   self (s)
20480              0.027934     let l:priority = g:ale#util#style_warning_priority
                            
                                " Determine the highest priority item for the line.
54339              0.043034     for l:item in a:sublist
33859   0.394105   0.130693         let l:item_priority = ale#util#GetItemPriority(l:item)
                            
33859              0.039656         if l:item_priority > l:priority
20480              0.024226             let l:priority = l:item_priority
33859              0.013215         endif
54339              0.023853     endfor
                            
20480              0.023352     if l:priority is# g:ale#util#error_priority
                                    return 'ALEErrorSign'
20480              0.008254     endif
                            
20480              0.022676     if l:priority is# g:ale#util#warning_priority
20480              0.015571         return 'ALEWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_error_priority
                                    return 'ALEStyleErrorSign'
                                endif
                            
                                if l:priority is# g:ale#util#style_warning_priority
                                    return 'ALEStyleWarningSign'
                                endif
                            
                                if l:priority is# g:ale#util#info_priority
                                    return 'ALEInfoSign'
                                endif
                            
                                " Use the error sign for invalid severities.
                                return 'ALEErrorSign'

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:177
Called 3 times
Total time:   0.012620
 Self time:   0.000731

count  total (s)   self (s)
    3   0.000430   0.000052   call gitgutter#debug#log(a:diff)
                            
    3              0.000026   if !bufexists(a:bufnr)
                                return
    3              0.000005   endif
                            
    3   0.003032   0.000115   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    3   0.006279   0.000099   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    3              0.000024   let signs_count = len(modified_lines)
    3              0.000022   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    3              0.000007   else
    3              0.000020     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    3   0.002240   0.000081       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    3              0.000006     endif
    3              0.000005   endif
                            
    3   0.000320   0.000065   call s:save_last_seen_change(a:bufnr)
    3              0.000044   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    3              0.000006   endif

FUNCTION  ale#util#GetMatches()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:325
Called 7 times
Total time:   0.204191
 Self time:   0.204191

count  total (s)   self (s)
    7              0.000007     let l:matches = []
    7              0.000024     let l:lines = type(a:lines) is v:t_list ? a:lines : [a:lines]
    7              0.000022     let l:patterns = type(a:patterns) is v:t_list ? a:patterns : [a:patterns]
                            
14447              0.010391     for l:line in l:lines
14449              0.015452         for l:pattern in l:patterns
14440              0.111407             let l:match = matchlist(l:line, l:pattern)
                            
14440              0.017933             if !empty(l:match)
14431              0.020234                 call add(l:matches, l:match)
14431              0.006356                 break
    9              0.000006             endif
14449              0.006069         endfor
14447              0.005498     endfor
                            
    7              0.000008     return l:matches

FUNCTION  <SNR>90_GroupLoclistItems()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:261
Called 7 times
Total time:   0.300053
 Self time:   0.300053

count  total (s)   self (s)
    7              0.000012     let l:grouped_items = []
    7              0.000009     let l:last_lnum = -1
                            
33866              0.020422     for l:obj in a:loclist
33859              0.032340         if l:obj.bufnr != a:buffer
                                        continue
33859              0.012048         endif
                            
                                    " Create a new sub-List when we hit a new line.
33859              0.032672         if l:obj.lnum != l:last_lnum
20480              0.027420             call add(l:grouped_items, [])
33859              0.012512         endif
                            
33859              0.059000         call add(l:grouped_items[-1], l:obj)
33859              0.036891         let l:last_lnum = l:obj.lnum
33866              0.013448     endfor
                            
    7              0.000007     return l:grouped_items

FUNCTION  <SNR>174_indent_items()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:212
Called 1 time
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    1              0.000014   if a:prev_line =~# s:envs_item && a:line !~# s:envs_enditem
                                return s:sw
    1              0.000022   elseif a:line =~# s:envs_endlist && a:prev_line !~# s:envs_begitem
                                return -s:sw
    1              0.000010   elseif a:line =~# s:envs_item && a:prev_line !~# s:envs_item
                                let l:prev_lnum = a:prev_lnum
                                let l:prev_line = a:prev_line
                                while l:prev_lnum >= 1
                                  if l:prev_line =~# s:envs_begitem
                                    return -s:sw*(l:prev_line =~# s:envs_item)
                                  endif
                                  let l:prev_lnum = prevnonblank(l:prev_lnum - 1)
                                  let l:prev_line = getline(l:prev_lnum)
                                endwhile
    1              0.000002   endif
                            
    1              0.000003   return 0

FUNCTION  ale#linter#RemoveIgnored()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:419
Called 3 times
Total time:   0.000177
 Self time:   0.000076

count  total (s)   self (s)
                                " Apply ignore lists for linters only if needed.
    3   0.000077   0.000021     let l:ignore_config = ale#Var(a:buffer, 'linters_ignore')
    3   0.000064   0.000019     let l:disable_lsp = ale#Var(a:buffer, 'disable_lsp')
                            
    3              0.000027     return !empty(l:ignore_config) || l:disable_lsp   ? ale#engine#ignore#Exclude(a:filetype, a:linters, l:ignore_config, l:disable_lsp)   : a:linters

FUNCTION  <SNR>160_parse_args()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/pos.vim:67
Called 9 times
Total time:   0.000416
 Self time:   0.000416

count  total (s)   self (s)
                              "
                              " The arguments should be in one of the following forms (when unpacked):
                              "
                              "   [lnum, cnum]
                              "   [bufnum, lnum, cnum, ...]
                              "   {'lnum' : lnum, 'cnum' : cnum}
                              "
                            
    9              0.000040   if len(a:args) > 1
                                return s:parse_args([a:args])
    9              0.000035   elseif len(a:args) == 1
    9              0.000053     if type(a:args[0]) == v:t_dict
                                  return [get(a:args[0], 'lnum'), get(a:args[0], 'cnum')]
    9              0.000009     else
    9              0.000035       if len(a:args[0]) == 2
                                    return a:args[0]
    9              0.000009       else
    9              0.000036         return a:args[0][1:]
                                  endif
                                endif
                              else
                                return a:args
                              endif

FUNCTION  ale#path#FindNearestExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/path.vim:82
Called 12 times
Total time:   0.004453
 Self time:   0.000661

count  total (s)   self (s)
   36              0.000044     for l:path in a:path_list
   24   0.000391   0.000151         if ale#path#IsAbsolute(l:path)
                                        let l:executable = filereadable(l:path) ? l:path : ''
   24              0.000012         else
   24   0.003688   0.000136             let l:executable = ale#path#FindNearestFile(a:buffer, l:path)
   24              0.000020         endif
                            
   24              0.000044         if !empty(l:executable)
                                        return l:executable
   24              0.000013         endif
   36              0.000035     endfor
                            
   12              0.000009     return ''

FUNCTION  vimtex#env#is_inside()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/env.vim:306
Called 2 times
Total time:   0.000341
 Self time:   0.000341

count  total (s)   self (s)
    2              0.000021   let l:re_start = '\\begin\s*{' . a:env . '\*\?}'
    2              0.000013   let l:re_end = '\\end\s*{' . a:env . '\*\?}'
    2              0.000005   try
    2              0.000245     return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', 0, 100)
                              catch /E118/
                                let l:stopline = max([line('.') - 500, 1])
                                return searchpairpos(l:re_start, '', l:re_end, 'bnW', '', l:stopline)
    2              0.000007   endtry

FUNCTION  ale#command#CreateTempFile()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:110
Called 9 times
Total time:   0.076340
 Self time:   0.015517

count  total (s)   self (s)
    9              0.000018     if empty(a:temporary_file)
                                    " There is no file, so we didn't create anything.
                                    return 0
    9              0.000004     endif
                            
                                " Use an existing list of lines of input if we have it, or get the lines
                                " from the file.
    9              0.014877     let l:lines = a:input isnot v:null ? a:input : getbufline(a:buffer, 1, '$')
                            
    9              0.000050     let l:temporary_directory = fnamemodify(a:temporary_file, ':h')
                                " Create the temporary directory for the file, unreadable by 'other'
                                " users.
    9              0.000351     call mkdir(l:temporary_directory, '', 0750)
                                " Automatically delete the directory later.
    9   0.000243   0.000070     call ale#command#ManageDirectory(a:buffer, l:temporary_directory)
                                " Write the buffer out to a file.
    9   0.060708   0.000058     call ale#util#Writefile(a:buffer, l:lines, a:temporary_file)
                            
    9              0.000023     return 1

FUNCTION  <SNR>40_Remove_Matches()
    Defined: /usr/share/vim/vim90/plugin/matchparen.vim:196
Called 20 times
Total time:   0.000336
 Self time:   0.000336

count  total (s)   self (s)
   20              0.000135   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
   20              0.000023   endif

FUNCTION  <SNR>90_GroupCmd()
    Defined: ~/.vim/bundle/ale/autoload/ale/sign.vim:162
Called 7272 times
Total time:   0.014360
 Self time:   0.014360

count  total (s)   self (s)
 7272              0.007191     if s:supports_sign_groups
 7272              0.005414         return ' group=ale '
                                else
                                    return ' '
                                endif

FUNCTION  <SNR>91_SetListsImpl()
    Defined: ~/.vim/bundle/ale/autoload/ale/list.vim:100
Called 7 times
Total time:   6.451518
 Self time:   0.039664

count  total (s)   self (s)
    7              0.000166     let l:title = expand('#' . a:buffer . ':p')
                            
    7              0.000009     if g:ale_set_quickfix
                                    let l:quickfix_list = ale#list#GetCombinedList()
                            
                                    if has('nvim')
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list), ' ', l:title)
                                    else
                                        call setqflist(s:FixList(a:buffer, l:quickfix_list))
                                        call setqflist([], 'r', {'title': l:title})
                                    endif
    7              0.000007     elseif g:ale_set_loclist
                                    " If windows support is off, win_findbuf() may not exist.
                                    " We'll set result in the current window, which might not be correct,
                                    " but it's better than nothing.
    7   0.000074   0.000031         let l:ids = s:WinFindBuf(a:buffer)
                            
    7   4.892043   0.000038         let l:loclist = s:Deduplicate(a:loclist)
                            
   14              0.000027         for l:id in l:ids
    7              0.000036             if has('nvim')
                                            call setloclist(l:id, s:FixList(a:buffer, l:loclist), ' ', l:title)
    7              0.000004             else
    7   1.548978   0.029521                 call setloclist(l:id, s:FixList(a:buffer, l:loclist))
    7              0.000057                 call setloclist(l:id, [], 'r', {'title': l:title})
    7              0.000007             endif
   14              0.000008         endfor
    7              0.000003     endif
                            
                                " Save the current view before opening/closing any window
    7              0.000040     call setbufvar(a:buffer, 'ale_winview', winsaveview())
                            
                                " Open a window to show the problems if we need to.
                                "
                                " ShouldOpen() checks if the current buffer has enough problems to be
                                " opened.
    7   0.009344   0.009156     if s:ShouldOpen(a:buffer, len(a:loclist))
                                    let l:winnr = winnr()
                                    let l:mode = mode()
                            
                                    " open windows vertically instead of default horizontally
                                    let l:open_type = ''
                            
                                    if ale#Var(a:buffer, 'list_vertical') == 1
                                        let l:open_type = 'vert rightbelow '
                                    endif
                            
                                    if g:ale_set_quickfix
                                        if !ale#list#IsQuickfixOpen()
                                            silent! execute l:open_type . 'copen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                        endif
                                    elseif g:ale_set_loclist
                                        silent! execute l:open_type . 'lopen ' . str2nr(ale#Var(a:buffer, 'list_window_size'))
                                    endif
                            
                                    " If focus changed, restore it (jump to the last window).
                                    if l:winnr isnot# winnr()
                                        wincmd p
                                    endif
                            
                                    " Return to original mode when applicable
                                    if mode() != l:mode
                                        if l:mode is? 'v' || l:mode is# "\<c-v>"
                                            " Reset our last visual selection
                                            normal! gv
                                        elseif l:mode is? 's' || l:mode is# "\<c-s>"
                                            " Reset our last character selection
                                            normal! "\<c-g>"
                                        endif
                                    endif
                            
                                    call s:RestoreViewIfNeeded(a:buffer)
    7              0.000002     endif
                            
                                " If ALE isn't currently checking for more problems, close the window if
                                " needed now. This check happens inside of this timer function, so
                                " the window can be closed reliably.
    7   0.000100   0.000035     if !ale#engine#IsCheckingBuffer(a:buffer)
    3   0.000109   0.000013         call s:CloseWindowIfNeeded(a:buffer)
    7              0.000005     endif

FUNCTION  <SNR>87_OnCursorMovedNormalMode()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:818
Called 8 times
Total time:   0.002516
 Self time:   0.001175

count  total (s)   self (s)
    8   0.001454   0.000113   if !s:AllowedToCompleteInCurrentBuffer()
                                return
    8              0.000007   endif
                            
    8              0.001029   py3 ycm_state.OnCursorMoved()

FUNCTION  ale#engine#HandleLoclist()
    Defined: ~/.vim/bundle/ale/autoload/ale/engine.vim:108
Called 7 times
Total time:  10.645897
 Self time:   0.474337

count  total (s)   self (s)
    7              0.000044     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
    7              0.000012     if empty(l:info)
                                    return
    7              0.000004     endif
                            
    7              0.000007     if !a:from_other_source
                                    " Remove this linter from the list of active linters.
                                    " This may have already been done when the job exits.
    7              0.000040         call filter(l:info.active_linter_list, 'v:val.name isnot# a:linter_name')
    7              0.000002     endif
                            
                                " Make some adjustments to the loclists to fix common problems, and also
                                " to set default values for loclist items.
    7   1.089789   0.000059     let l:linter_loclist = ale#engine#FixLocList(   a:buffer,   a:linter_name,   a:from_other_source,   a:loclist,)
                            
                                " Remove previous items for this linter.
    7              0.031061     call filter(l:info.loclist, 'v:val.linter_name isnot# a:linter_name')
                            
                                " We don't need to add items or sort the list when this list is empty.
    7              0.000022     if !empty(l:linter_loclist)
                                    " Add the new items.
    7              0.000725         call extend(l:info.loclist, l:linter_loclist)
                            
                                    " Sort the loclist again.
                                    " We need a sorted list so we can run a binary search against it
                                    " for efficient lookup of the messages in the cursor handler.
    7   3.319398   0.442176         call sort(l:info.loclist, 'ale#util#LocItemCompare')
    7              0.000001     endif
                            
    7   0.000741   0.000034     if ale#ShouldDoNothing(a:buffer)
                                    return
    7              0.000002     endif
                            
    7   6.203951   0.000050     call ale#engine#SetResults(a:buffer, l:info.loclist)

FUNCTION  gitgutter#utility#file()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:82
Called 3 times
Total time:   0.000701
 Self time:   0.000062

count  total (s)   self (s)
    3   0.000694   0.000055   return s:abs_path(a:bufnr, 1)

FUNCTION  <SNR>80_VimCloseCallback()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:88
Called 9 times
Total time:  11.003898
 Self time:   0.000469

count  total (s)   self (s)
    9              0.000028     let l:job = ch_getjob(a:channel)
    9   0.000124   0.000082     let l:job_id = ale#job#ParseVim8ProcessID(string(l:job))
    9              0.000032     let l:info = get(s:job_map, l:job_id, {})
                            
    9              0.000018     if empty(l:info)
                                    return
    9              0.000006     endif
                            
                                " job_status() can trigger the exit handler.
                                " The channel can close before the job has exited.
    9  11.003525   0.000138     if job_status(l:job) is# 'dead'
    9              0.000007         try
    9              0.000030             if !empty(l:info) && has_key(l:info, 'exit_cb')
                                            " We have to remove the callback, so we don't call it twice.
                                            call ale#util#GetFunction(remove(l:info, 'exit_cb'))(l:job_id, get(l:info, 'exit_code', 1))
    9              0.000005             endif
    9              0.000004         finally
                                        " Automatically forget about the job after it's done.
    9              0.000016             if has_key(s:job_map, l:job_id)
                                            call remove(s:job_map, l:job_id)
    9              0.000004             endif
    9              0.000004         endtry
    9              0.000004     endif

FUNCTION  <SNR>55_GetLinterNames()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:336
Called 3 times
Total time:   0.000167
 Self time:   0.000167

count  total (s)   self (s)
    3              0.000017     let l:buffer_ale_linters = get(b:, 'ale_linters', {})
                            
                                " b:ale_linters can be set to 'all'
    3              0.000007     if l:buffer_ale_linters is# 'all'
                                    return 'all'
    3              0.000003     endif
                            
                                " b:ale_linters can be set to a List.
    3              0.000011     if type(l:buffer_ale_linters) is v:t_list
                                    return l:buffer_ale_linters
    3              0.000003     endif
                            
                                " Try to get a buffer-local setting for the filetype
    3              0.000011     if has_key(l:buffer_ale_linters, a:original_filetype)
                                    return l:buffer_ale_linters[a:original_filetype]
    3              0.000002     endif
                            
                                " Try to get a global setting for the filetype
    3              0.000015     if has_key(g:ale_linters, a:original_filetype)
                                    return g:ale_linters[a:original_filetype]
    3              0.000004     endif
                            
                                " If the user has configured ALE to only enable linters explicitly, then
                                " don't enable any linters by default.
    3              0.000005     if g:ale_linters_explicit
                                    return []
    3              0.000003     endif
                            
                                " Try to get a default setting for the filetype
    3              0.000015     if has_key(s:default_ale_linters, a:original_filetype)
                                    return s:default_ale_linters[a:original_filetype]
    3              0.000001     endif
                            
    3              0.000004     return 'all'

FUNCTION  ale#history#Get()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:8
Called 14 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
   14              0.000104     return copy(getbufvar(a:buffer, 'ale_history', []))

FUNCTION  <SNR>174_indent_delims()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:240
Called 1 time
Total time:   0.000561
 Self time:   0.000079

count  total (s)   self (s)
    1              0.000008   if s:re_delim_trivial | return 0 | endif
                            
    1              0.000003   if s:re_opt.close_indented
                                return s:sw*(vimtex#util#count(a:prev_line, s:re_open) - vimtex#util#count(a:prev_line, s:re_close))
    1              0.000002   else
    1   0.000533   0.000051     return s:sw*(vimtex#util#count_open(a:prev_line, s:re_open, s:re_close)      - vimtex#util#count_close(a:line, s:re_open, s:re_close))
                              endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:50
Called 6 times
Total time:   0.002876
 Self time:   0.000361

count  total (s)   self (s)
    6   0.002862   0.000347   return gitgutter#utility#getbufvar(a:bufnr, 'enabled') && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>34_exists_file()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:240
Called 6 times
Total time:   0.000982
 Self time:   0.000201

count  total (s)   self (s)
    6   0.000969   0.000188   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  <SNR>87_PollFileParseResponse()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:762
Called 2 times
Total time:   0.000422
 Self time:   0.000422

count  total (s)   self (s)
    2              0.000244   if !py3eval( "ycm_state.FileParseRequestReady()" )
                                let s:pollers.file_parse_response.id = timer_start( s:pollers.file_parse_response.wait_milliseconds, function( 's:PollFileParseResponse' ) )
                                return
    2              0.000001   endif
                            
    2              0.000120   py3 ycm_state.HandleFileParseRequest()
    2              0.000038   if py3eval( "ycm_state.ShouldResendFileParseRequest()" )
                                call s:OnFileReadyToParse( 1 )
    2              0.000002   endif

FUNCTION  <lambda>203()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.691017
 Self time:   0.000014

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  <lambda>204()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.758876
 Self time:   0.000015

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#history#Add()
    Defined: ~/.vim/bundle/ale/autoload/ale/history.vim:12
Called 30 times
Total time:   0.007885
 Self time:   0.007885

count  total (s)   self (s)
   30              0.000056     if g:ale_max_buffer_history_size <= 0
                                    " Don't save anything if the history isn't a positive number.
                                    call setbufvar(a:buffer, 'ale_history', [])
                            
                                    return
   30              0.000012     endif
                            
   30              0.000216     let l:history = getbufvar(a:buffer, 'ale_history', [])
                            
                                " Remove the first item if we hit the max history size.
   30              0.000086     if len(l:history) >= g:ale_max_buffer_history_size
   30              0.000728         let l:history = l:history[1:]
   30              0.000016     endif
                            
   30              0.000213     call add(l:history, {   'status': a:status,   'job_id': a:job_id,   'command': a:command,})
                            
   30              0.006261     call setbufvar(a:buffer, 'ale_history', l:history)

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/diff.vim:209
Called 3 times
Total time:   0.002047
 Self time:   0.000647

count  total (s)   self (s)
    3              0.000018   let hunks = []
   12              0.000150   for line in split(a:diff, '\n')
    9   0.001624   0.000224     let hunk_info = gitgutter#diff#parse_hunk(line)
    9              0.000055     if len(hunk_info) == 4
    9              0.000065       call add(hunks, hunk_info)
    9              0.000018     endif
   12              0.000023   endfor
    3              0.000011   return hunks

FUNCTION  <SNR>188_StartIfExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:405
Called 3 times
Total time:   0.000303
 Self time:   0.000049

count  total (s)   self (s)
    3   0.000025   0.000015     if ale#command#IsDeferred(a:executable)
                                    let a:executable.result_callback = {   executable -> s:StartIfExecutable(a:options, executable)}
                            
                                    return 1
    3              0.000000     endif
                            
    3   0.000257   0.000013     if !ale#engine#IsExecutable(a:options.buffer, a:executable)
    3              0.000003         return 0
                                endif
                            
                                let l:command = ale#linter#GetCommand(a:options.buffer, a:options.linter)
                            
                                return s:StartWithCommand(a:options, a:executable, l:command)

FUNCTION  <lambda>200()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.753993
 Self time:   0.000016

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#util#StartPartialTimer()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:460
Called 7 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    7              0.000046     let l:timer_id = timer_start(a:delay, function('s:ApplyPartialTimer'))
    7              0.000028     let s:partial_timers[l:timer_id] = [a:callback, a:args]
                            
    7              0.000010     return l:timer_id

FUNCTION  <lambda>208()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.350377
 Self time:   0.000016

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#linter#GetExecutable()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:430
Called 30 times
Total time:   0.005591
 Self time:   0.000342

count  total (s)   self (s)
   30              0.000078     let l:Executable = a:linter.executable
                            
   30   0.005483   0.000234     return type(l:Executable) is v:t_func   ? l:Executable(a:buffer)   : l:Executable

FUNCTION  <SNR>174_get_prev_lnum()
    Defined: ~/.vim/bundle/vimtex/indent/tex.vim:76
Called 1 time
Total time:   0.000394
 Self time:   0.000111

count  total (s)   self (s)
    1              0.000005   let l:lnum = a:lnum
    1              0.000008   let l:line = getline(l:lnum)
                            
    1   0.000294   0.000047   while l:lnum != 0 && (l:line =~# '^\s*%' || s:is_verbatim(l:line, l:lnum))
                                let l:lnum = prevnonblank(l:lnum - 1)
                                let l:line = getline(l:lnum)
    1              0.000003   endwhile
                            
    1   0.000066   0.000030   return [ l:lnum, l:lnum > 0 ? s:clean_line(l:line) : '',]

FUNCTION  <SNR>87_AllowedToCompleteInCurrentBuffer()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:524
Called 12 times
Total time:   0.001789
 Self time:   0.000155

count  total (s)   self (s)
   12   0.001779   0.000145   return s:AllowedToCompleteInBuffer( '%' )

FUNCTION  ale#job#PrepareCommand()
    Defined: ~/.vim/bundle/ale/autoload/ale/job.vim:175
Called 9 times
Total time:   0.000618
 Self time:   0.000491

count  total (s)   self (s)
    9   0.000196   0.000069     let l:wrapper = ale#Var(a:buffer, 'command_wrapper')
                            
                                " The command will be executed in a subshell. This fixes a number of
                                " issues, including reading the PATH variables correctly, %PATHEXT%
                                " expansion on Windows, etc.
                                "
                                " NeoVim handles this issue automatically if the command is a String,
                                " but we'll do this explicitly, so we use the same exact command for both
                                " versions.
    9              0.000042     let l:command = !empty(l:wrapper) ? s:PrepareWrappedCommand(l:wrapper, a:command) : a:command
                            
                                " If a custom shell is specified, use that.
    9              0.000019     if exists('b:ale_shell')
                                    let l:ale_shell = b:ale_shell
    9              0.000014     elseif exists('g:ale_shell')
                                    let l:ale_shell = g:ale_shell
    9              0.000007     endif
                            
    9              0.000015     if exists('l:ale_shell')
                                    let l:shell_arguments = get(b:, 'ale_shell_arguments', get(g:, 'ale_shell_arguments', &shellcmdflag))
                            
                                    return split(l:ale_shell) + split(l:shell_arguments) + [l:command]
    9              0.000003     endif
                            
    9              0.000019     if has('win32')
                                    return 'cmd /s/c "' . l:command . '"'
    9              0.000004     endif
                            
    9              0.000069     if &shell =~? 'fish$\|pwsh$'
                                    return ['/bin/sh', '-c', l:command]
    9              0.000004     endif
                            
    9              0.000079     return split(&shell) + split(&shellcmdflag) + [l:command]

FUNCTION  ale#util#GetFunction()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:88
Called 14456 times
Total time:   0.063004
 Self time:   0.063004

count  total (s)   self (s)
14456              0.023161     if type(a:string_or_ref) is v:t_string
    7              0.000014         return function(a:string_or_ref)
14449              0.006023     endif
                            
14449              0.011825     return a:string_or_ref

FUNCTION  ale#util#Tempname()
    Defined: ~/.vim/bundle/ale/autoload/ale/util.vim:301
Called 9 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    9              0.000022     let l:clear_tempdir = 0
                            
    9              0.000035     if exists('$TMPDIR') && empty($TMPDIR)
                                    let l:clear_tempdir = 1
                                    let $TMPDIR = '/tmp'
    9              0.000003     endif
                            
    9              0.000006     try
    9              0.000033         let l:name = tempname() " no-custom-checks
    9              0.000009     finally
    9              0.000007         if l:clear_tempdir
                                        let $TMPDIR = ''
    9              0.000004         endif
    9              0.000006     endtry
                            
    9              0.000007     return l:name

FUNCTION  ale#lsp_linter#CheckWithLSP()
    Defined: ~/.vim/bundle/ale/autoload/ale/lsp_linter.vim:492
Called 3 times
Total time:   0.001224
 Self time:   0.000032

count  total (s)   self (s)
    3   0.001222   0.000030     return ale#lsp_linter#StartLSP(a:buffer, a:linter, function('s:CheckWithLSP'))

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/utility.vim:21
Called 51 times
Total time:   0.001659
 Self time:   0.001659

count  total (s)   self (s)
   51              0.000500   let ggvars = getbufvar(a:buffer, 'gitgutter')
   51              0.000771   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
   51              0.000260     return ggvars[a:varname]
                              endif
                              if a:0
                                return a:1
                              endif

FUNCTION  <lambda>207()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.704643
 Self time:   0.000015

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#command#RemoveManagedFiles()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:83
Called 1 time
Total time:   0.000687
 Self time:   0.000676

count  total (s)   self (s)
    1              0.000004     let l:info = get(s:buffer_data, a:buffer, {})
                            
    1              0.000003     if !empty(l:info) && empty(l:info.jobs)
                                    " We can't delete anything in a sandbox, so wait until we escape from
                                    " it to delete temporary files and directories.
    1   0.000014   0.000003         if ale#util#InSandbox()
                                        return
    1              0.000001         endif
                            
                                    " Delete files with a call akin to a plan `rm` command.
    1              0.000002         for l:filename in l:info.file_list
                                        call delete(l:filename)
    1              0.000001         endfor
                            
                                    " Delete directories like `rm -rf`.
                                    " Directories are handled differently from files, so paths that are
                                    " intended to be single files can be set up for automatic deletion
                                    " without accidentally deleting entire directories.
   10              0.000010         for l:directory in l:info.directory_list
    9              0.000632             call delete(l:directory, 'rf')
   10              0.000008         endfor
                            
    1              0.000004         call remove(s:buffer_data, a:buffer)
    1              0.000001     endif

FUNCTION  ale#linter#GetCwd()
    Defined: ~/.vim/bundle/ale/autoload/ale/linter.vim:438
Called 9 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
    9              0.000027     let l:Cwd = get(a:linter, 'cwd', v:null)
                            
    9              0.000038     return type(l:Cwd) is v:t_func ? l:Cwd(a:buffer) : l:Cwd

FUNCTION  vimtex#syntax#in_comment()
    Defined: ~/.vim/bundle/vimtex/autoload/vimtex/syntax.vim:23
Called 9 times
Total time:   0.001506
 Self time:   0.000135

count  total (s)   self (s)
    9   0.001501   0.000130   return call('vimtex#syntax#in', ['texComment'] + a:000)

FUNCTION  <lambda>209()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:360
Called 1 time
Total time:   1.161074
 Self time:   0.000013

count  total (s)   self (s)
                            return s:ExitCallback(       a:buffer,       l:line_list,       a:Callback,       {           'job_id': job_id,           'exit_code': exit_code,           'temporary_file': l:temporary_file,           'log_output': get(l:options, 'log_output', 1),           'result': l:result,       }   )

FUNCTION  ale#command#StopJobs()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:261
Called 3 times
Total time:   0.000273
 Self time:   0.000158

count  total (s)   self (s)
    3              0.000031     let l:info = get(s:buffer_data, a:buffer, {})
                            
    3              0.000010     if !empty(l:info)
    3              0.000007         let l:new_map = {}
                            
    5              0.000023         for [l:job_id, l:job_type] in items(l:info.jobs)
    2              0.000004             let l:job_id = str2nr(l:job_id)
                            
    2              0.000005             if a:job_type is# 'all' || a:job_type is# l:job_type
    2   0.000122   0.000007                 call ale#job#Stop(l:job_id)
                                        else
                                            let l:new_map[l:job_id] = l:job_type
    2              0.000000             endif
    5              0.000002         endfor
                            
    3              0.000010         let l:info.jobs = l:new_map
    3              0.000002     endif

FUNCTION  ale#cursor#EchoCursorWarningWithDelay()
    Defined: ~/.vim/bundle/ale/autoload/ale/cursor.vim:115
Called 8 times
Total time:   0.001165
 Self time:   0.000830

count  total (s)   self (s)
    8              0.000080     let l:buffer = bufnr('')
                            
    8              0.000035     if !g:ale_echo_cursor && !g:ale_cursor_detail
                                    return
    8              0.000011     endif
                            
                                " Only echo the warnings in normal mode, otherwise we will get problems.
    8              0.000045     if mode(1) isnot# 'n'
                                    return
    8              0.000007     endif
                            
    8   0.000228   0.000103     call s:StopCursorTimer()
                            
    8              0.000102     let l:pos = getpos('.')[0:2]
                            
    8              0.000041     if !exists('w:last_pos')
                                    let w:last_pos = [0, 0, 0]
    8              0.000009     endif
                            
                                " Check the current buffer, line, and column number against the last
                                " recorded position. If the position has actually changed, *then*
                                " we should echo something. Otherwise we can end up doing processing
                                " the echo message far too frequently.
    8              0.000029     if l:pos != w:last_pos
    8   0.000300   0.000090         let l:delay = ale#Var(l:buffer, 'echo_delay')
                            
    8              0.000032         let w:last_pos = l:pos
    8              0.000078         let s:cursor_timer = timer_start(   l:delay,   function('ale#cursor#EchoCursorWarning'))
    8              0.000009     endif

FUNCTION  <SNR>75_TemporaryFilename()
    Defined: ~/.vim/bundle/ale/autoload/ale/command.vim:132
Called 9 times
Total time:   0.000367
 Self time:   0.000186

count  total (s)   self (s)
    9              0.000043     let l:filename = fnamemodify(bufname(a:buffer), ':t')
                            
    9              0.000019     if empty(l:filename)
                                    " If the buffer's filename is empty, create a dummy filename.
                                    let l:ft = getbufvar(a:buffer, '&filetype')
                                    let l:filename = 'file' . ale#filetypes#GuessExtension(l:ft)
    9              0.000003     endif
                            
                                " Create a temporary filename, <temp_dir>/<original_basename>
                                " The file itself will not be created by this function.
    9   0.000246   0.000065     return ale#util#Tempname() . (has('win32') ? '\' : '/') . l:filename

FUNCTION  <lambda>175()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/lacheck.vim:38
Called 3 times
Total time:   0.000048
 Self time:   0.000007

count  total (s)   self (s)
                            return ale#Var(b, 'tex_lacheck_executable')

FUNCTION  <lambda>176()
    Defined: ~/.vim/bundle/ale/ale_linters/tex/texlab.vim:19
Called 3 times
Total time:   0.000068
 Self time:   0.000030

count  total (s)   self (s)
                            return ale#Var(b, 'tex_texlab_executable')

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/bundle/vim-gitgutter/autoload/gitgutter/hunk.vim:5
Called 3 times
Total time:   0.000870
 Self time:   0.000158

count  total (s)   self (s)
    3   0.000374   0.000083   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    3   0.000488   0.000067   call s:reset_summary(a:bufnr)

FUNCTION  <SNR>87_ClearSignatureHelp()
    Defined: ~/.vim/bundle/YouCompleteMe/autoload/youcompleteme.vim:1164
Called 3 times
Total time:   0.009486
 Self time:   0.006051

count  total (s)   self (s)
    3   0.003436   0.000027   if !s:ShouldUseSignatureHelp()
                                return
    3              0.000004   endif
                            
    3   0.000065   0.000039   call s:StopPoller( s:pollers.signature_help )
    3              0.000012   let s:signature_help = s:default_signature_help
    3              0.005954   call py3eval( 'ycm_state.ClearSignatureHelp()' )

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    9  11.003898   0.000469  <SNR>80_VimCloseCallback()
    9  11.003387   0.000378  <SNR>80_VimExitCallback()
    9  11.002794   0.008285  <SNR>75_ExitCallback()
    7  10.993605   0.006646  <SNR>74_HandleExit()
    7  10.645897   0.474337  ale#engine#HandleLoclist()
509764   6.638072   6.453866  ale#util#LocItemCompare()
    7   6.451648   0.000130  <SNR>54_ApplyPartialTimer()
    7   6.451518   0.039664  <SNR>91_SetListsImpl()
    7   6.203901   0.022467  ale#engine#SetResults()
    7   4.892005   0.563285  <SNR>91_Deduplicate()
230394   4.328720   1.321781  ale#util#LocItemCompareWithText()
    7   3.950963   0.085812  ale#sign#SetSigns()
    7   2.229420   0.049069  ale#highlight#SetHighlights()
    7   2.180248   0.598407  ale#highlight#UpdateHighlights()
    1   1.758876   0.000015  <lambda>204()
    1   1.753993   0.000016  <lambda>200()
    1   1.704643   0.000015  <lambda>207()
    1   1.691017   0.000014  <lambda>203()
    1   1.582900   0.000017  <lambda>199()
    7   1.532821   0.763258  <SNR>90_BuildSignMap()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
509764   6.638072   6.453866  ale#util#LocItemCompare()
230394   4.328720   1.321781  ale#util#LocItemCompareWithText()
32620              1.097129  ale#GetLocItemMessage()
    7   1.089730   1.079385  ale#engine#FixLocList()
27174              0.987817  <SNR>92_matchaddpos()
    7   1.532821   0.763258  <SNR>90_BuildSignMap()
    7   0.636013   0.612486  ale#sign#GetSignCommands()
    7   2.180248   0.598407  ale#highlight#UpdateHighlights()
    7   4.892005   0.563285  <SNR>91_Deduplicate()
20480   0.769479   0.506067  ale#sign#GetSignName()
    7  10.645897   0.474337  ale#engine#HandleLoclist()
    7   1.220964   0.467053  <SNR>90_UpdateLineNumbers()
58395              0.447618  ale#util#GetItemPriority()
    7   1.519457   0.422240  <SNR>91_FixList()
    7              0.300053  <SNR>90_GroupLoclistItems()
27174   1.378119   0.279033  <SNR>92_highlight_range()
14440   0.369883   0.232012  <SNR>80_VimOutputCallback()
    7              0.204191  ale#util#GetMatches()
    7              0.203722  ale#highlight#RemoveHighlights()
    7              0.171757  ale#sign#ParseSignsWithGetPlaced()

