# _proc_onedim.py
# Simon Hulse
# simon.hulse@chem.ox.ac.uk
# Last Edited: Tue 12 Dec 2023 08:25:09 PM EST

import copy
from pathlib import Path
from typing import Iterable, Optional, Tuple, Union

import matplotlib as mpl
from matplotlib import cm, pyplot as plt
import numpy as np
from pybaselines.classification import dietrich

import nmrespy as ne
from nmrespy import sig
from nmrespy.estimators import Estimator, logger, Result
from nmrespy.write import ResultWriter
from nmrespy._colors import GRE, END, USE_COLORAMA
from nmrespy._files import check_saveable_path
from nmrespy._sanity import sanity_check, funcs as sfuncs

if USE_COLORAMA:
    import colorama
    colorama.init()


class _Estimator1DProc(Estimator):
    """Parent class for estimators which require processing/filtering in a single
    dimension. i.e. 1D, 2DJ."""

    @property
    def spectrum_first_direct(self) -> np.ndarray:
        """Generate a 1D spectrum of the first signal in the direct dimension.

        Generated by taking the first direct-dimension slice (``self.data[0]``),
        halving the initial point, and applying FT.
        """
        data = copy.deepcopy(self.data[0])
        data[0] *= 0.5
        return ne.sig.ft(data)

    def predict_regions(
        self,
        unit: str = "hz",
        min_baseline_length: int = 15,
        true_region_filter: int = 200,
    ) -> Iterable[Tuple[float, float]]:
        # TODO: docstring
        # TODO: sanity checking
        if self.data.ndim == 1:
            data = copy.deepcopy(self.data)
        else:
            data = self.data[0]
        data[0] *= 0.5
        spectrum = ne.sig.ft(data).real
        shifts = self.get_shifts(unit=unit)[-1]
        mask = dietrich(
            spectrum,
            x_data=shifts,
            min_length=min_baseline_length,
        )[1]["mask"].astype(int)
        mask_diff = np.abs(np.diff(mask))
        flip_idxs, = np.nonzero(mask_diff == 1)
        flip_iter = iter(flip_idxs)

        region_idxs = []
        if mask[0] == 0:
            region_idxs.append(0)
        else:
            region_idxs.append(int(next(flip_iter)))
        region_idxs.extend([int(idx) for idx in flip_iter])
        if mask[-1] == 0:
            region_idxs.append(mask.size - 1)

        region_freqs = iter(self.convert([region_idxs], f"idx->{unit}")[0])
        regions = [(l, r) for l, r in zip(region_freqs, region_freqs)]  # noqa: E741

        # Filter away sufficiently small regions
        width_threshold = (
            self.convert([0], f"idx->{unit}")[0] -
            self.convert([true_region_filter], f"idx->{unit}")[0]
        )
        regions = list(filter(lambda r: r[0] - r[1] >= width_threshold, regions))

        return regions

    def view_proposed_regions(
        self,
        regions: Iterable[Tuple[float, float]],
        unit: str = "hz",
    ) -> None:
        # TODO docstring
        # TODO sanity checking
        if self.data.ndim == 1:
            data = copy.deepcopy(self.data)
        else:
            data = self.data[0]
        data[0] *= 0.5
        spectrum = ne.sig.ft(data).real
        shifts = self.get_shifts(unit=unit)[-1]

        fig, ax = plt.subplots()
        ax.set_xlim(shifts[0], shifts[-1])
        ax.plot(shifts, spectrum, color="k")
        colors = cm.viridis(np.linspace(0, 1, len(regions)))
        for region, color in zip(regions, colors):
            ax.axvspan(
                region[0],
                region[1],
                facecolor=color,
                alpha=0.6,
                edgecolor=None,
            )

        ax.set_yticks([])
        ax.set_xlabel(self._axis_freq_labels(unit)[-1])

        plt.show()

    @logger
    def subband_estimate(
        self,
        noise_region: Tuple[float, float],
        noise_region_unit: str = "hz",
        nsubbands: Optional[int] = None,
        **estimate_kwargs,
    ) -> None:
        r"""Perform estiamtion on the entire signal via estimation of
        frequency-filtered sub-bands.

        This method splits the signal up into ``nsubbands`` equally-sized region
        and extracts parameters from each region before finally concatenating all
        the results together.

        .. warning::

            This method is a work-in-progress. It is unlikely to produce decent
            results at the moment! I aim to improve the way that regions are
            created in the future.

        Parameters
        ----------
        noise_region
            Specifies a frequency range where no noticeable signals reside, i.e. only
            noise exists.

        noise_region_unit
            One of ``"hz"`` or ``"ppm"``. Specifies the units that ``noise_region``
            have been given in.

        nsubbands
            The number of sub-bands to break the signal into. If ``None``, the number
            will be set as the nearest integer to the data size divided by 500.

        estimate_kwargs
            Keyword arguments to give to :py:meth:`estimate`. Note that ``region``
            and ``initial_guess`` will be ignored.
        """
        sanity_check(
            self._funit_check(noise_region_unit, "noise_region_unit"),
            ("nsubbands", nsubbands, sfuncs.check_int, (), {"min_value": 1}, True),
        )
        sanity_check(
            self._region_check(noise_region, noise_region_unit, "noise_region"),
        )

        regions, mid_regions = self._get_subbands(nsubbands)
        nsubbands = len(regions)
        noise_region = self.convert(
            (self.dim - 1) * [None] + [noise_region],
            f"{noise_region_unit}->hz",
        )[-1]

        fprint = "fprint" not in estimate_kwargs or estimate_kwargs["fprint"]
        if fprint:
            print(f"Starting sub-band estimation using {nsubbands} sub-bands:")

        for string in ("region", "region_unit", "initial_guess", "_log"):
            if string in estimate_kwargs:
                del estimate_kwargs[string]

        params, errors = None, None
        for i, (region, mid_region) in enumerate(zip(regions, mid_regions), start=1):
            if fprint:
                msg = (
                    f"--> Estimating region #{i}: "
                    f"{mid_region[0]:.2f} - {mid_region[1]:.2f}Hz"
                )
                if self.hz_ppm_valid:
                    mid_region_ppm = self.convert(
                        (self.dim - 1) * [None] + [mid_region],
                        "hz->ppm"
                    )[-1]
                    msg += f" ({mid_region_ppm[0]:.3f} - {mid_region_ppm[1]:.3f}ppm)"
                print(msg)

            self.estimate(
                region, noise_region, region_unit="hz", _log=False,
                **estimate_kwargs,
            )
            p, e = self._keep_middle_freqs(self._results.pop(), mid_region)

            if p is None:
                continue
            if params is None:
                params = p
                errors = e
            else:
                params = np.vstack((params, p))
                errors = np.vstack((errors, e))

        # Sort in order of direct-dimension freqs.
        sort_idx = np.argsort(params[:, self.dim + 1])
        params = params[sort_idx]
        errors = errors[sort_idx]

        if fprint:
            print(f"{GRE}Sub-band estimation complete.{END}")

        self._results.append(
            Result(
                params,
                errors,
                region=self._full_region,
                noise_region=None,
                sfo=self.sfo,
            )
        )

    def _get_subbands(self, nsubbands: Optional[int]):
        # N.B. This is only appropriate for Estimator1D and Estimator2DJ
        if nsubbands is None:
            nsubbands = int(np.ceil(self.data.shape[-1] / 500))

        idxs, mid_idxs = self._get_subband_indices(nsubbands)
        shifts = self.get_shifts(meshgrid=False)[-1]
        regions = [(shifts[idx[0]], shifts[idx[1]]) for idx in idxs]
        mid_regions = [(shifts[mid_idx[0]], shifts[mid_idx[1]]) for mid_idx in mid_idxs]

        return regions, mid_regions

    def _get_subband_indices(
        self,
        nsubbands: int,
    ) -> Tuple[Iterable[Tuple[int, int]], Iterable[Tuple[int, int]]]:
        # (nsubbands - 2) full-size regions plus 2 half-size regions on each end.
        size = self.data.shape[-1]
        width = int(np.ceil(2 * size / (nsubbands - 1)))
        mid_width = int(np.ceil(width / 2))
        start_factor = int(np.ceil(size / (nsubbands - 1)))
        idxs = []
        mid_idxs = []
        for i in range(0, nsubbands - 2):
            start = i * start_factor
            mid_start = int(np.ceil((i + 0.5) * start_factor))
            if i == nsubbands - 3:
                idxs.append((start, size - 1))
            else:
                idxs.append((start, start + width))
            mid_idxs.append((mid_start, mid_start + mid_width))

        idxs.insert(0, (0, start_factor))
        idxs.append(((nsubbands - 2) * start_factor, size - 1))
        mid_idxs.insert(0, (0, mid_idxs[0][0]))
        mid_idxs.append((mid_idxs[-1][-1], size - 1))

        return idxs, mid_idxs

    def _keep_middle_freqs(
        self,
        result: Result,
        mid_region: Tuple[float, float],
    ) -> Tuple[np.ndarray, np.ndarray]:
        if result.params.size == 0:
            return None, None
        to_remove = (
            list(np.nonzero(result.params[:, 1 + self.dim] >= mid_region[0])[0]) +
            list(np.nonzero(result.params[:, 1 + self.dim] < mid_region[1])[0])
        )
        return (
            np.delete(result.params, to_remove, axis=0),
            np.delete(result.errors, to_remove, axis=0),
        )

    @logger
    def write_result(
        self,
        path: Union[Path, str] = "./nmrespy_result",
        indices: Optional[Iterable[int]] = None,
        fmt: str = "txt",
        description: Optional[str] = None,
        sig_figs: Optional[int] = 5,
        sci_lims: Optional[Tuple[int, int]] = (-2, 3),
        integral_mode: str = "relative",
        force_overwrite: bool = False,
        fprint: bool = True,
        pdflatex_exe: Optional[Union[str, Path]] = None,
    ) -> None:
        r"""Write estimation result tables to a text/PDF file.

        Parameters
        ----------
        path
            Path to save the result file to.

        indices
            see :ref:`INDICES`

        fmt
            Must be one of ``"txt"`` or ``"pdf"``. If you wish to generate a PDF, you
            must have a LaTeX installation. See :ref:`LATEX_INSTALL`\.

        description
            Descriptive text to add to the top of the file.

        sig_figs
            The number of significant figures to give to parameters. If
            ``None``, the full value will be used. By default this is set to ``5``.

        sci_lims
            Given a value ``(-x, y)`` with ints ``x`` and ``y``, any parameter ``p``
            with a value which satisfies ``p < 10 ** -x`` or ``p >= 10 ** y`` will be
            expressed in scientific notation. If ``None``, scientific notation
            will never be used.

        integral_mode
            One of ``"relative"`` or ``"absolute"``.

            * If ``"relative"``, the smallest integral will be set to ``1``,
              and all other integrals will be scaled accordingly.
            * If ``"absolute"``, the absolute integral will be computed. This
              should be used if you wish to directly compare different datasets.

        force_overwrite
            Defines behaviour if the specified path already exists:

            * If ``False``, the user will be prompted if they are happy
              overwriting the current file.
            * If ``True``, the current file will be overwritten without prompt.

        fprint
            Specifies whether or not to print information to the terminal.

        pdflatex_exe
            The path to the system's ``pdflatex`` executable.

            .. note::

               You are unlikely to need to set this manually. It is primarily
               present to specify the path to ``pdflatex.exe`` on Windows when
               the NMR-EsPy GUI has been loaded from TopSpin.
        """
        self._check_results_exist()
        sanity_check(
            self._indices_check(indices),
            ("fmt", fmt, sfuncs.check_one_of, ("txt", "pdf")),
            ("description", description, sfuncs.check_str, (), {}, True),
            ("sig_figs", sig_figs, sfuncs.check_int, (), {"min_value": 1}, True),
            ("sci_lims", sci_lims, sfuncs.check_sci_lims, (), {}, True),
            (
                "integral_mode", integral_mode, sfuncs.check_one_of,
                ("relative", "absolute"),
            ),
            ("force_overwrite", force_overwrite, sfuncs.check_bool),
            ("fprint", fprint, sfuncs.check_bool),
        )
        sanity_check(("path", path, check_saveable_path, (fmt, force_overwrite)))

        indices = self._process_indices(indices)
        results = self.get_results(indices=indices)
        writer = ResultWriter(
            self.expinfo,
            [result.get_params() for result in results],
            [result.get_errors() for result in results],
            description,
        )
        region_unit = "ppm" if self.hz_ppm_valid else "hz"

        titles = []
        for result in results:
            if result.get_region() is None:
                titles.append("Full signal")
            else:
                left, right = result.get_region(region_unit)[-1]
                titles.append(
                    f"{left:.3f} - {right:.3f} {region_unit}".replace("h", "H")
                )

        writer.write(
            path=path,
            fmt=fmt,
            titles=titles,
            parameters_sig_figs=sig_figs,
            parameters_sci_lims=sci_lims,
            integral_mode=integral_mode,
            force_overwrite=True,
            fprint=fprint,
            pdflatex_exe=pdflatex_exe,
        )

    def _plot_regions(
        self,
        indices: Iterable[int],
        region_unit: str,
    ) -> Tuple[Iterable[Iterable[int]], Iterable[Tuple[float, float]]]:
        regions = sorted(
            [
                (i, result.get_region(unit=region_unit)[-1])
                for i, result in enumerate(self.get_results())
                if i in indices
            ],
            key=lambda x: x[1][0],
            reverse=True,
        )

        # Merge overlapping/bordering regions
        merge_indices = []
        merge_regions = []
        for idx, region in regions:
            assigned = False
            for i, reg in enumerate(merge_regions):
                if max(region) >= min(reg):
                    merge_regions[i] = (max(reg), min(region))
                    assigned = True
                elif min(region) >= max(reg):
                    merge_regions[i] = (max(region), min(reg))
                    assigned = True

                if assigned:
                    merge_indices[i].append(idx)
                    break

            if not assigned:
                merge_indices.append([idx])
                merge_regions.append(region)

        return merge_indices, merge_regions

    def _configure_axes(
        self,
        fig: mpl.figure.Figure,
        axs: np.ndarray[mpl.axes.Axes],
        regions: Iterable[Tuple[float, float]],
        xaxis_ticks: Iterable[Tuple[int, Iterable[float]]],
        axes_left: float,
        axes_right: float,
        xaxis_label_height: float,
        region_unit: str,
    ) -> None:
        if axs.shape[0] > 1:
            for ax in axs[0]:
                ax.spines["bottom"].set_visible(False)
                ax.set_xticks([])
                ax.set_yticks([])
            for ax in axs[1]:
                ax.spines["top"].set_visible(False)
        for region, ax_col in zip(regions, axs.T):
            for ax in ax_col:
                ax.set_xlim(*region)

        if len(regions) > 1:
            for axs_col in axs[:, :-1]:
                for ax in axs_col:
                    ax.spines["right"].set_visible(False)
            for axs_col in axs[:, 1:]:
                for ax in axs_col:
                    ax.spines["left"].set_visible(False)

            break_kwargs = {
                "marker": [(-1, -3), (1, 3)],
                "markersize": 6,
                "linestyle": "none",
                "color": "k",
                "mec": "k",
                "mew": mpl.rcParams["lines.linewidth"],
                "clip_on": False,
            }
            for ax in axs[0, :-1]:
                ax.plot([1], [1], transform=ax.transAxes, **break_kwargs)
            for ax in axs[0, 1:]:
                ax.plot([0], [1], transform=ax.transAxes, **break_kwargs)
            for ax in axs[-1, :-1]:
                ax.plot([1], [0], transform=ax.transAxes, **break_kwargs)
            for ax in axs[-1, 1:]:
                ax.plot([0], [0], transform=ax.transAxes, **break_kwargs)
                ax.set_yticks([])

        if xaxis_ticks is not None:
            for i, ticks in xaxis_ticks:
                axs[-1, i].set_xticks(ticks)

        label = self._axis_freq_labels(region_unit)[-1]

        fig.text(
            x=(axes_left + axes_right) / 2,
            y=xaxis_label_height,
            s=label,
            horizontalalignment="center",
        )
